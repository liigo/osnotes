# cow

## 原理

fork 只会为子进程创建一个空的用户页表（当然 trampoline 页还是要有的），并对于 sz 以下的虚拟地址空间，子进程和父进程完全映射到相同的物理页帧。且双方对于页表项的权限控制进行修改：若之前是可写的，现在变为不可写。

当某个进程尝试写入用户数据段的时候，会触发 page fault，这个时候我们重新分配一个物理页帧，并将原来物理页帧上的数据复制过去。当前进程映射到这个新的物理页面。最后将两个相关进程用户页表的页表项都加上写权限。

这样实现之后，多个进程的用户页表可能会映射到同一个物理页。对于某个物理页而言，只有在最后一个能够映射到它的进程退出之后，我们才会释放这个物理页。

## lab: 实现 COW

* 目标：通过 cowtest 和 usertests。在 cowtest 里面会有一个进程分配超过半数的物理内存并多次 fork。
* 提示：我们无须同时实现懒分配和写时复制，这里只需单独实现写时复制即可，那么也就可以保证 sz 以下的虚拟页面都被映射到物理页帧了。
* 提示：一种可行的方案是，修改 `uvmcopy` 使得它不再重新分配物理页面而是跟原来的页表映射到相同的页面，同时两个页表都不带有 PTE_W。
* 提示：修改 `usertrap` ，使得在 COW page 上触发 store page fault 的时候，重新分配一个物理页帧，拷贝已有的物理页帧上的数据，并以添加了 PTE_W 的权限映射到当前进程的用户页表。注意，无论父进程还是子进程，都会重新分配一个物理页帧，而不是在修改权限之后继续用已有的物理页帧。
* 提示：因此，两个进程均写入一个虚拟页面之后，最早的物理页帧需要被回收，我们需要在 `kalloc.c` 中实现某种引用计数机制。 只需在链表中加入一个新的 field 即可。
* 提示：`copyout` 也会产生对于用户页表进行写入的行为，如果遇到了 COW 的虚拟页，也要类似于 store page fault 的逻辑直接在内核进行处理。
* 提示：在 PTE 中记录当前的虚拟页面是处于 COW 的未写入状态还是正常的页面可能是很有用的。这可以使用 PTE 中的保留位。