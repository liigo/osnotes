# lazy

## 实验指导书阅读

### 实验动机

我们可以通过 `sbrk` 向 OS 申请更多的虚拟内存空间来使用。但是一次性申请大量内存会很慢（OS 需要手动清空实际的物理页帧），而且它们也并不是马上就都要用到。于是需要改进 `sbrk` 系统调用，让它不再直接分配物理页帧，而是先使得能够找到页表项，在页表项里面标记为不合法。这样用户第一次访问该区域的时候会触发 page fault，进到 OS 之后再分配物理页帧并映射，然后返回用户态重新执行出问题的那条指令。

### 阅读 4.6 节：page fault exception

xv6 目前对于异常的处理有点一刀切：若它发生在 user（检查 SPP）则直接杀死当前进程；若它发生在 kernel 则直接整个内核 panic。但是常见的 OS 对异常的处理会更加有趣。

比如 xv6 原来 fork 的实现是要为子进程新建一个独立于父进程但内容完全相同的用户地址空间，内存占用较多，且在创建的时候有数据拷贝开销。但是如果直接子进程和父进程映射到相同的物理页面，两个进程的执行都会受到影响。

基于 RISC-V 的 page fault 可以为 fork 实现写时复制（COW, Copy on Write）机制。原理是父进程和子进程共享用户数据段（代码段可以安全共享）所有相关的物理页面，但是权限都改成只读。无论父进程和子进程哪一个尝试进行写入，都会触发 store page fault，在服务例程中我们可以分配一个物理页面并进行数据复制，这样就有两个物理页面了，父进程和子进程分别以可以写入的权限映射到不同页面，它们至少对于这个虚拟地址区间的访问就不会产生冲突了。此外，COW 机制对于调用 fork 的用户程序而言是透明的。

很多情况下子进程 fork 出来之后都会立即调用 exec，这种情况下基于 COW 机制只需进行少数的页面复制就能够完成地址空间的替换。

基于 page fault 还能做到很多有意思的事情，比如为 sbrk 实现懒分配机制。这个之前的实验动机已经分析了。另一个可能是 *paging from disk*，这个不知道如何翻译...也就是“传统意义”上的虚拟存储。其他的可能包括自动栈拓展或者是将文件映射到内存（*memory-mapped files*）。

## lab: 消除 sbrk() 的物理页帧分配

* 修改 `sysproc.c` 里面 `sys_sbrk` 的实现，让它仅仅修改 `myproc()->sz` 而不会调用 `growproc` 函数。
* 这样的话，进入 xv6 之后 `echo hi` 会报出 page fault。

## lab：懒分配

* 修改 `trap.c` 中的 `usertrap` 方法使得它能对 page fault 做出响应：分配一个新的物理页帧映射到当前的用户地址空间，然后返回回去执行之前的访存指令。
* 提示：通过 `r_scause` 确定 trap 原因，通过 `r_stval` 确定访存出现问题的虚拟地址，通过 `PGROUNDDOWN` 宏来找到访存出现问题的虚拟页
* 提示：响应 page fault 的方式参考 `uvmalloc` 通过 `kalloc` 和 `mappages` 进行实现
* 提示：对于 `uvmunmap` 进行修改，让它不要再 panic

## lab: 通过综合测试

* 和之前的所有机制结合到一起，通过 lazytest 和贯穿始终的 usertest。
* 提示：若  sbrk 参数为负数，我们需要减少 sz、解映射并回收相应的物理页面；
* 提示：若 page fault 的 stval 超过了当前进程的 sz 需要杀死进程；
* 提示：在 fork 的时候正确实现地址空间的拷贝，即只复制那些存在的页面并进行映射
* 提示：可能产生实际分配的另一个途径是：在内核态读用户地址空间的时候，地址不超过当前进程的 sz，但是尚未被映射到实际物理页面
* 提示：正确实现 oom，如果在 page fault handler （应该不局限于这个，还包括其他 syscall 或 trap）里面 kalloc 失败，则直接杀死当前进程并释放内存
* 提示：记住 exec 会在用户运行栈下面设置一个 guard page，它没有 PTE_V。如果 page fault 发生在这里则应该被认为是爆栈，需要杀死进程，而不是懒分配。

