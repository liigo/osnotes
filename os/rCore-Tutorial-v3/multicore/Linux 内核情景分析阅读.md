# Chapter9 多处理器的 SMP 系统结构

## 9.1 概述

* 与单处理机架构相比需要进一步考虑的事情：
  * **同步互斥**。在单处理机中只需考虑中断处理例程不会访问当前的中间状态，甚至可以关闭中断，再不济通过原子指令都可以构造原子块解决所有问题；而对于多核而言，关闭中断显然不起作用了，对于单核满足原子性的原子指令也失效了
  * **高速缓存与内存的一致性问题**。这个相对比较复杂，简要来说就是一个核需要知道其他核对于内存的修改情况，也需要即使修改自己的高速缓存来与内存中的内容保持一致。当然，这还与缓存的策略有关。取决于缓存策略的设置不同，事实上高速缓存还会打乱内存访问的顺序，即从 *program ordering* 变成 *processor ordering*，当然 CPU 对于指令的乱序执行也是因素之一。此外，SMP 需要高速缓存的意义在于，内存一般不允许多个 CPU 在同一时钟周期进行访问，如果缓存使用得当，那么可以大大减少内存访问带来的冲突
  * **对中断的处理**。如何将中断合理分配到不同的 CPU 上进行处理。（比如 RISC-V 架构上的 PLIC/CLINT）

## 9.2 SMP 结构中的互斥问题

* 单纯的读/写指令本来就是原子的，但对于一些像是寄存器交换这样存在多个阶段的指令，i386 CPU 提供给这种指令加锁的手段，即执行期间给总线加锁，使得其他 CPU 暂时不能通过总线访问内存

* 高速缓存与内存的数据一致性应该由硬件解决（*但是猜测一下，如何用好它尽可能提高性能则是软件要做的事情*）

* 由于高速缓存、指令乱序执行的影响，使得 CPU 上可能会有一些逻辑上已经完成，但是物理上尚未实现的内存操作，需要有一种手段督促 CPU 将这些“欠下的债”还上，这种手段称为内存屏障

  在奔腾处理器中有多种方式提供内存屏障：

  1. 凡是对系统总线加锁的指令都起到内存屏障的作用，在执行该条指令之前会将高速缓存中的内容写回到内存中；
  2. 一些特殊的指令与操作也起到内存屏障的作用。

## 9.3 高速缓存与内存的一致性

* 我们知道，在 CPU 上配置的高速缓存主要分为如下三种：

  1. 对访问内存进行的缓冲，又分为数据缓存和指令缓存，主要会产生问题的是数据缓存；
  2. 快表 TLB；
  3. 写内存缓冲区：即 CPU 想要将数据写回内存但发现目前总线已上锁的时候，只能先将数据写到一个缓冲区上，待总线可用后再进行写入操作

* 对于数据缓存，实际上 CPU 有一种窥探（snooping）机制，会监听总线上其他 CPU 对于内存的访问，一旦发现修改后的内容与自身的高速缓存产生了冲突，就会丢弃掉对应的缓存线，从而保证一致性；

* 对于 TLB，主要是通过 IPI 机制由软件进行控制：即当某个 CPU 修改了页表使得其他 CPU 上的 TLB 失去一致性之后，可以通过 IPI 通知对应的 CPU 刷新 TLB 上的相应缓存线

  后面结合代码的具体解释好复杂QAQ...先不看了（Page 1446）

## 9.4 SMP 结构中的中断机制



## 9.5 SMP 结构中的进程调度

## 9.6 SMP 系统的引导

