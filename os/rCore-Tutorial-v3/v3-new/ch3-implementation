第三章实现：
每个应用程序加载到不同的物理地址，0x80040000+0x20000*n，n>=0
每个应用程序有自己的用户栈和内核栈
每个应用程序需要维护一些运行状态的信息，也就是 PCB 的雏形。目前需要维护的是：
1. 内核栈的位置，也就代表了任务切换上下文的位置
2. 应用程序 ID（未来将被 PID 所替代）

第三章分成两个阶段。一是通过 sys_yield 进行手动切换。二是应用程序中不出现 sys_yield，而是借助时钟中断自动切换。
这一章只需要 FIFO 就行，而且也不存在阻塞。最简单的实现方法就是把 PCB 放在一个全局数组里面固定下来，可能还是和上一章一样把数组包到一个新的类型里面。然后搞一个指针 p 扫描一下就行。因此也不需要有 idle 的存在。两个阶段分别是不同的情况：
1. 当 sys_yield 的时候，从 p 切换成 p + 1
2. 当通过时钟中断进入 S 的时候，从 p 切换成 p + 1
因此本章也不需要保存任务的状态。（这是在多核、阻塞机制存在的时候才会有的问题）
同样，也并不需要保存当前核的状态（比如之前还是需要保存一个 Arc<Thread> 的）

最关键的是 __task_switch 的实现，传入的两个参数分别是当前任务未压入 TaskContext 的内核栈 sp，以及待切换到的任务压入 TaskContext 之后的内核栈 sp。
这个可能要回去参考第二版的实现。参数是一个 sp 还是 &mut TaskContext 呢？此外还要注意执行流状态的保存。所以执行流状态要保存什么东西？
之前似乎是在一个大的 switch 里面包着内联汇编。说来滑稽，我感觉编译期真正帮忙保存的只有 ra，当然它确实也是最显著的一个。
之前的做法里面是手动保存 ra 的，而且也只保存了 ra 和 s0~s11 还有 satp，目前还用不到 satp。在调用大 switch 之前调用者可能会自动保存部分调用者保存寄存器，但不包括 ra。
在调用大 switch 那一时刻 ra 会被覆盖成调用大 switch 的下一条指令的地址，所以这个 ra 必须保存，实话说我觉得编译器会帮助我们保存的。
而且跟我们自己实现的汇编代码也能兼容。
然后在整个过程中 sp 的位置：在调用大 switch 那一瞬间 sp 就是这个时候任务所属内核栈的栈顶（上面分析知道它只会出现在 sys_yield 或者时钟中断中）。

时钟中断就已经带来麻烦事了：如果在内核态触发时钟中断会如何？我人都傻了，当然是不会了，trap 进来之后就已经自动关中断了。当然我们不考虑中断嵌套。但是遇到异常的时候，也就是系统调用或者可恢复错误的等耗时非常长的时候可以视情况打开某些中断。但是其中的绝大多数问题都可以通过阻塞机制来解决。所以这里我们也不用过于追求公平性。甚至在整本书中都是如此。于是，中断何时打开？
1. 放在 spie 中，进入 U 之后打开
2. 直接打开
后面我们还是需要内核线程。可以把内核线程和用户进程作为两个不同的类型，都实现可以加入调度器的 Trait。这个也直接丢到第五章进程/线程去吧。接口到时候还需要再设计一下。于是可能直接打开还会好一点？

另外，要不要将上一章 AppManager 重命名为 AppLoader ？我觉得这好像更接近它实际的功能，AppManager 有点像是这一章的功能... 

具体实现：将 batch.rs 改成 loader.rs，AppManager 重命名为 AppLoader，上一章的对应内容也需要修改，现在 AppLoader 的功能是将应用程序的内容加载到内存，并将构造好的 Trap 上下文压到每个应用程序的内核栈的栈顶， 并将它的位置保存下来。
然后开一个新的模块，叫做：manager?里面维护每个应用需要维护的信息，主要负责切换行为。

那到底什么时候引入多核，又要做出哪些变化呢？令人头痛啊。

另一个问题是，这章需要引入堆内存分配吗？还是应该一起放到第四章的。

user: 在 link_user.S 里面提供哪些内容？还是和以前一样，这个时候需要约定按照应用程序编号



