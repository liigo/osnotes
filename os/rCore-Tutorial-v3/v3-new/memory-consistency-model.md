# 内存一致性模型提纲

如果想深入理解各种同步互斥原理的话，目前最好还是从内存一致性模型这个层面来入手来进行解释。

从应用的角度来考虑，在多线程的情况下就会出现不同的代码路径并发修改同一个数据结构的情形。更准确的说，可能是同一块内存上的数据。

---

在必须存在多级cache保证基本性能的情况下，如果正确完成同步是一件很复杂的事情！

---

coherence规定哪些值能够被看到（以读的方式返回），而consistency规定一个写入的值何时应当被看到。

一个存储系统是coherent的几条规定：

1. 同一个核P对于某内存位置X的先写后读，如果在这两次操作中间不存在其他核对X的写入，则能够读到写入的值。
2. 如果核P写入内存位置X之后核Q读内存位置X，两次操作中间间隔时间足够长且不存在其他核写入X，则Q能够读到P写入的值。
3. 不同核对同一内存位置的写入（即使同一时间触发）是串行的，且所有核都能够看到这唯一的写入顺序。即如果先写入v1再写入v2，没有核能够先看到v2再看到v1。

但是consistent也非常重要：考虑两个核几乎同一时间读（略微靠后）和写同一内存位置，那么读者几乎不可能立即就看到写入的值（这个时候可能还没进入cache/总线/内存，可能还在流水线的早期位置），于是consistency可以约束读者在什么时刻之前必须看到写者写入的值。

先主要探讨coherence，于是可以暂时做两点假设：

1. 某个核一次写入直到所有的核都已经看到该次写入的影响（比如，期间可能会进行一些invalidation）之后才能结束。
2. 处理器不会对任何写入进行乱序（读取则可以）而是会维持程序顺序。

这意味着，在这种处理器的实现之下，如果一个核先写入内存地址A再写入内存地址B，那么所有看到了地址B新值的核也必然能够看到地址A的新值。但是，这会引入不必要的依赖关系从而影响性能。因此该假设后面还会被放宽。

---

coherence问题在访存和I/O时均存在，但后者很容易解决，因为基本上很少出现数据的多份拷贝的情况，而多线程就并非如此。

因此，在SMP场景下，需要支持缓存行的迁移（migration）和复制（replication）。迁移意味着一个缓存行可以被移动到一个局部缓存，从而降低访问一个共享数据项的延迟，同时也能降低总线的带宽需求（比如可以在局部缓存直接找到就无需涉及总线了）。同样的，将一个局部缓存中的缓存行复制到另一个局部缓存，也可以降低访问延迟以及对于读取该共享缓存行的数据竞争。对于访问共享数据而言，支持缓存行的迁移和复制都是非常重要的。但是，这在软件上不太容易完成，因此目前主流的观点是基于**缓存一致性协议(cache coherence protocol)**在硬件层面完成。

缓存一致性协议最关键的部分是跟踪每个数据块的共享状态。缓存块的状态以附加比特位的形式和缓存块自身一并保存。目前已投入使用的协议可大致分为两大类，它们各自使用不同的手段来跟踪缓存块的共享状态：

* 基于目录的一致性协议

  

* 窥探式的一致性协议



