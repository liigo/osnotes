原文来自于CMU的[课件](https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf)。

锁同步存在的问题：

* 死锁
* 优先级反置：低优先级持有高优先级进程要获取的锁（可能的解决方案：优先级继承）
* 锁护送/锁封护（lock convoying）：多个同等优先级线程争抢同一把锁，每次一个线程获取锁失败，它将立即放弃调度给它的时间片并进行上下文切换。整体来看，上下文切换的开销相当大。另一种情况下，有一个需要持有锁很长时间的线程最先获取到锁，于是所有线程都需要等待它。
* 异步信号安全：信号服务例程不能使用基于锁的原语，特别是malloc/free。否则当持有锁的时候处理信号将造成死锁。
* kill/抢占容忍：如果线程在持有锁的情况下panic、被杀死、被抢占？
* 总体性能：确实存在许多基于锁的性能优秀的算法。这涉及到实现便利性和效率之间的权衡。比如说要实现一个拥有很多节点的共享链表，用锁来保护整个链表？读写锁？还是每个节点上锁？

无锁编程就是允许多线程互斥访问共享数据，但不用如同互斥锁之类的锁原语来实现。如果不利用硬件特性的话，可能能做到但是并不实用。如果利用硬件特性实现则十分具有实用价值，比如曾经的很多用户态的音乐软件均用到无锁数据结构。

设计无锁算法的一般步骤：很难设计通用的无锁算法，因此通常设计通用的无锁数据结构，如缓冲区、列表、栈、队列、映射、双向队列、快照等。它们通常基于更简单的原语来实现，如硬件平台提供的CAS指令。注意不能用基于锁的数据结构来实现无锁算法。

比如，简单的无锁栈实现：