# 第四章文档设计

## LOG

2021-01-11：看了一些文档大概把逻辑盘明白了，回去之后整理一下思路。

## 大概的顺序...

### 地址空间与内存管理子系统

地址空间抽象的来源：多任务系统->应用同时驻留内存->内存安全性问题->地址空间抽象（透明、高效、保护）

内存管理子系统发展史：

* （透明！）静态重定位
* 每个应用 base+bound，地址空间大小相同，在内存中的位置连续，某种动态重定位（带来内碎片）
* 段式内存管理，每个应用中的每个段一个 base+bound，不够灵活，连续内存分配算法不易实现
* 页式内存管理，同样可以使用插槽式管理，(MMU)但是占用内存空间太大，同时带来了额外的访存次数
* 空间优化：段页式内存管理，多级页表
* 性能优化：TLB

### Rust 中的动态内存分配

* 好处（相比栈和全局数据段）
* 连续内存分配算法
* C 的情况

### 地址空间的实现

### 内核/用户地址空间布局

* 构建和解析应用
* 创建内核地址空间
* Trap 上下文保存/恢复

## All included...

* 动态内存分配的灵活性、开销和算法

  为什么要提供动态内存分配分配的能力？

  Rust 在堆上分配的数据结构（Rust 和 C 看起来有什么不同）

* 被淘汰的分段式管理

  RV64 的 SV39 分页式管理

  数据结构的组成

* 地址空间/物理地址和虚拟地址

  地址空间创建与 ELF 解析

  用户和内核地址空间的隔离

  Trap 带来的影响

  更加分明的 Trap 管理（来自不同的特权级）

* 物理页帧分配

## Major...

* 内存分配算法：内碎片\外碎片
* 

## 阅读 ostep

* 最早的时候 OS 还真的只是一个用户库，整体是一个裸机应用。（一切本来都是非常简单的，需求才是万恶之源啊！）多道程序是为了提高 CPU 利用率，分时系统是为了提高交互性来方便调试。最早的时候，**每个任务独占内存**，当一个任务被切换出去之前，需要将它的全部状态保存在磁盘中。但是太慢了！能否只保存寄存器呢？这就需要将多个任务同时驻留在内存中。之后，**保护**就非常重要了（那这个也算是对上了）。最终得出的满足以上需求、又易于使用的内存抽象就是**地址空间**。

* 地址空间就是应用能看到的内存，包含代码段、数据段、堆和栈。设计目标是透明、高效和保护（隔离，在建立可靠系统的时候很重要）。应用中的所有地址都是虚拟地址。

* 堆上的数据可以长期存活，但是（在 C 中）需要手动管理。而且（在 C 中）对于 malloc/free 的不当使用会带来很多错误。

* 高效和灵活的内存虚拟化。将丑陋的现实（应用共享内存）变为美好的幻觉（每个应用独占内存）

* 早期，通过 base+bound 寄存器实现**动态重定位**（不同于纯软件的静态重定位），所有的段均放在一个地址空间

  硬件需要提供：特权级机制/base+bound寄存器/MMU/相关配置的特权指令/可以产生异常/可以处理异常

  内核方面，假设地址空间在物理内存连续分布/大小不超过物理内存且为常数，直接维护一个桶就行了。注意在切换任务的同时要切换 base/bound 寄存器。

  但是地址空间大小为常数会带来内碎片。

* 分段：每个逻辑上功能不同的段都有一个base+bound，每个段都是**独立**的，于是这就更加灵活了，但是需要多套 base+bound。

  比如，在老式机器上，用虚拟地址的前两个比特作为段选择子（数据段/代码段/堆栈段），后面的是段内偏移，然后硬件就可以对应翻译了。这是显式方法，由于使用虚拟地址内的比特了，限制了每个段的大小。还有看起来比较厉害的隐式方法，可以自动判断地址的含义来推断它属于哪个段（但是肯定会有限制的吧）。

  然后用堆栈段说明了各个段的地址增长方向不同，需要硬件的额外支持。但是现在在 RV 中没有这个问题。

  通过标志位的适当设置可以实现段的共享，最典型的就是代码段的共享。

  一些古老的平台支持一个应用含有上千个段，从而需要在内存中维护一个所谓的**段表**，从而更加精细的段控制。

  内核这里终于要开始内存管理算法了，以段为单位，每个段的大小都是不同的。于是会存在**外碎片**。分配一个新的段或者 sbrk 来增长一个已有的段的时候，可能需要涉及到段的整体重排，带来很大的开销。

  算法自然就是 first-fit/best-fit/worst-fit 那些，还有 buddy system 。

  除了产生外碎片之外，分段内存管理的另一个问题是**不够灵活**。比如说加载应用的使用为它创建了一个很大的段作为堆，而它却很少使用，这就造成了内存的浪费。也就是说只有符合内核设计者预期的那些应用才能真正高效的使用资源。

* 分段等于是将完整的地址空间分成大小不等的块，从而管理起来比较复杂，会产生外碎片，或者 The World 。分页就是尝试把地址空间分成大小固定的块，地址空间的每个单元是一个页，物理内存提供的每个同等大小的插槽称为一个栈帧。好处首先是更加灵活了，我们不必关心每个段的地址增长方向了；其次是插槽式管理显然更加简单了，内核仍然可以维护一个 free-list 即可。

  硬件需要提供地址转换机制。每个应用都有自己的页表。
  
  内存消耗大：如果页表真的就是一个表，那么随着虚拟地址位宽的增加它的容量会增长非常迅速，硬件资源不足只能放在内存中，但是对于内存也是个非常大的消耗（这个之前的版本有提到）；
  
  速度慢：硬件进行地址翻译查页表的时候需要读一次额外的内存，这会浪费很多个 CPU 时钟周期。
  
  后面会有这两个问题的解决方案。
  
* TLB 会直接把虚拟地址到页表项的映射记录下来。
  
  为了减小页表的大小，尤其是避免为那些没被实际用到的虚拟地址预留空间，可以采用段页式或者是多级页表。
## 阅读 BlogOS 的内存管理章节

* 讲了一下栈上和全局数据段的一些缺点。

* 内存分配算法的话，就还是连续内存分配算法。

  当只需以一个固定大小的块为单位进行分配的时候，算法则退化为管理若干个离散的插槽，变得更加方便。



  

  

  

