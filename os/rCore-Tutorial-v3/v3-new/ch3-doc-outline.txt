第三章文档提纲

核心思想：当资源复用带来被覆盖的风险时，就势必需要保存。

代码实现中需要说明的部分：
1. 多个应用程序共存在内存中不同的位置。用户部分注意 build.py 在每次 cargo build 之前会修改掉 linker.ld 中的 BASE_ADDRESS；内核部分则是删掉了所谓的 AppManager，现在只有一个 loader 子模块，首先可以通过 load_apps 将所有应用加载到内存。然后 init_app_cx 是将 TrapContext 和 TaskContext 先后压入内核栈并返回 TaskContext 的地址，这个需要介绍完 TaskContext 之后再顺便介绍。顺带一提，在 loader 里面开了多个用户栈和内核栈，目前它还是静态分配。
2. TaskControlBlock 全程常驻内存描述一个 Task，它有两个字段：task_cx_ptr 表示它的 TaskContext 的地址（总是在内核栈的栈顶），task_status 表示 Task 当前的运行状态。目前一共有四种：UnInit/Ready/Running/Exited。
3. 在应用处于 S 特权级的时候可以通过 __switch 切换到一个之前被切换出去的应用。__switch 的逻辑是编译器帮忙保存可能的调用者保存寄存器，而 __switch 里面恢复了被调用者保存寄存器和 ra。从执行流的角度来看，当它需要被切换出去之前（另一个可能需要小心的事情是切换回来之后的表现是否符合我们的预期），该执行流的状态包括栈上的内容和全部寄存器。于是一种很好的构造是：通过一个 __switch 函数来完成切换。xv6 实现不同的是：它并没有修改栈，但是这似乎不是很对？xv6 里面只是传入两个 TaskContext 的指针保存和恢复寄存器罢了。目前还不是很能理解，按照自己的来吧。
4. 调度算法：目前是一个 RR 的简化版本，每次最坏情况下会扫描所有预加载的应用，即使它们中的某些已经退出。这里有一个是在保存当前执行的应用，在最后应该换成 CPU 的执行状态。对外暴露出的接口是 suspend_current_and_run_next 还有 exit_current_and_run_next，次重要的接口是 find_next 然后通过 __switch 切换过去。
5. 新的初始化：每个内核栈上需要依次压入 goto_restore 的 TaskContext 还有 initial TrapContext，并将相应的 task_cx_ptr 保存在 TaskControlBlock 中。也就是之前的 init_app_cx。
6. 抢占式调度：时钟中断。需要介绍 RV 中断的相关知识、中断屏蔽、特权级中断、sepc 会被设置为下一条指令（与异常不同）、中断的三种不同来源（特别的在外部中断的时候还要在详细讲，虽然主体是在附录里面了）。时钟中断的初始化：关掉（关掉，一定要关掉）相关的屏蔽，使用 sbi 提供的接口（它背后的故事可太丰富了），我们暂且就把它当成一个黑盒来用，作用是设置下一次触发中断的时间点。具体实现非常简单，只需 suspend_current_and_run_next 即可。特别的，在出现其他错误的时候和退出的时候一样都是 exit_current_and_run_next。

Intro：多任务就是多个应用程序同时在内存中，分时就是可以在它们之间自由切换，优点是 1. 能够在 CPU 忙等待的时候切换到其他应用（CPU 和 I/O 设备的速度矛盾），充分利用 CPU 资源； 2. 现代的 OS 普遍是多任务的。主要是展示一下 ch3-coop 和 ch3 两个分支的运行效果。（吐槽一下：Rust 的 release 优化真的挺强的，性能相比 debug 在当前应用中提升了近 4 倍）
part1 多任务内存布局：新的应用程序布局，说明它们在内存中的位置，user/ 如何进行编译，以及在 os/ 中如何进行加载。它会 task 模块传一个 app 数量的参数。
part2 任务上下文切换：设想一个应用需要在 S 特权级切换出去。直接引入 __switch 函数，说明其参数的含义，以及为何只需要保存这些参数。此外，引入 task_cx_ptr 被保存的位置，我们是为每个应用在内存中常驻一个 TaskControlBlock
part3 协作式调度：对应 ch3-coop 分支。首先说明应用程序的编写方式和期望运行方式，介绍协作式调度的概念以及关键的 sys_yield 调用。在实现的时候，绘制一张任务状态转移图。然后说明图中的每一条边如何实现（包括应用初始化）。介绍任务调度算法的概念，并说明目前是一种非常受限且简单的算法。
part4 时钟中断与抢占式调度：对应 ch3 分支。首先说明协作式调度的安全隐患并说明新版应用程序的编写和期望运行方式，介绍抢占式调度（时间片）的概念以及提到实现它需要用到时间中断。接下来开始介绍 RV64 硬件的中断相关机制以及时钟中断相关机制以及如何使用。具体实现还是要给出任务状态转移图并依次介绍每条边。和上一小节其实差不多。



备注：目前为止有可能实现 sys_alarm 吗？它包括注册、取消，然后每过一定时间自动
