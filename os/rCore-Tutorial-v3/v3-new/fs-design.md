## 极简文件系统设计

这里主要讨论一些文件系统布局的事情吧。块缓存和它完全正交，日志系统的话暂时也不做考虑。

> 顺带一提，xv6 还在内存里面放了 inode 的缓存。确实数据块和 inode 是在同一级别的存在。
>
> 如果没有缓存的话，比如一次文件系统操作，需要修改 inode，那么首先需要把 inode 读到内存（布局确保 inode 不会跨块），然后在内存中对于 inode 进行若干修改，最后将内存中的 inode 写回磁盘。
>
> 如果有缓存的话，可以并不急于写回磁盘，而是先在内存驻留，等到被换出的时候再写回磁盘。当然可能也有一个 sync 操作，将缓冲区域所有内容立刻写回磁盘。
>
> 以上的说明，对于数据块也是一样的道理。

块设备的每个块大小为 512 字节。

第一个块为超级块，里面包含着：

* 文件系统的总块数；
* 最多允许的 inode 数目；
* 最多允许的数据块数目。

先来确定一下 inode 里面的内容：

* 文件大小 `size`，大小 4 字节；
* 文件块数 `blocks`，大小 4 字节；
* 直接数据块索引 `direct: [u32; 12]`，大小 48 字节；
* 一级间接数据块索引 `indirect1`，大小 4 字节；
* 应该还需要一个文件类型 `type`。

如果只有一级间接索引块，最大支持大小为 (12+128)/2=70KiB 的文件

如果还有二级间接索引块，最大支持大小为(12+128+128\*128)/2=70KiB+8192KiB>8MiB 的文件

> 简单起见扔掉的元数据：
>
> * 权限控制信息；
> * 创建/修改/访问时间；
>
> xv6 里面没有记录 blocks，应该是直接用 size 来算出来。
>
> 由于 xv6 支持硬链接，所以有一个 nlinks 字段。
>
> xv6 里面的磁盘上 inode 一共有三种类型，分别是 DIR/FILE/DEVICE。
>
> 值得一提的是，DEVICE 应该仅需要 inode 提供的 major/minor 信息，然后会尝试从设备驱动子系统中找到一个这样的设备...总之是比较复杂且不必要的。可以后面再考虑处理。
>
> 至少在下一个阶段，inode 只需有 DIR 和 FILE 两种类型。

因此，一个 inode 不超过 64 字节，这样每个块就能至少放置 8 个 inode。

文件系统初始化的时候可以指定 inode bitmap 的块数表示支持放置多少个文件（好像不太健康），然后设置一个文件系统的总块数，则 data block bitmap 的块数可以用剩余总块数除以 4097 上取整得到。

然后就是，超不想每次把 microsd 拆下来...能不能搞一个 sdcard 烧写工具呢？这个开源出去应该也有很多人用。比如以 4M 为单位进行烧写，每次等待一定时间（或者以某种方式发现这一轮写入完成）之后就可以把 miniterm 进程杀死并开始一轮新的写入。这个只在自动测试的时候有用...暂时还不考虑。