# 2020年12月26日报告提纲

马上就要到 12 月 26 日的报告了...结果现在也就是堪堪写完代码，wtcl......

主要是文件系统真的真的比我想象中要难写，这是一种完全不同的独特架构。一开始我并没有照着 rcore-fs 去写，但是最后写完之后却感觉跟 rcore-fs 挺像的。

那么就稍微研究一下讲的内容吧...

## 报告题目

rCore-Tutorial 设计与实现？

## 要强调的事情（总）

Rust 到底什么地方比 C 更好了？

宣传 RustSBI/rCore-Tutorial-v3

绘制大量的图片，尽可能避免文字

## 一些可能不太重要的事情

其他 k210 移植

>[汇总仓库](https://github.com/oscomp/os-kernel-demos)
>
>[xv6 porting c/k210](https://github.com/SKTT1Ryze/xv6-k210)
>
>[xv6 rewritten in rust rust/qemu](https://github.com/Jaic1/xv6-riscv-rust)
>
>[ucore porting c/k210](https://github.com/NKU-EmbeddedSystem/riscv64-ucore)

## 既往 Tutorial 历史以及新版 Tutorial 的动机

想想有些羞耻...QWQ但是当然要挑选长处来说啦。毕竟不能 罪  己  诏 不是？

（有趣的问题：rcore 还是 rCore 哪个更正统？）

这里可能需要列一张表。

| 时间       | 版本       | 是否支持多核 | 指令集 | 支持平台  | 是否支持外存 | 作者                |
| ---------- | ---------- | ------------ | ------ | --------- | ------------ | ------------------- |
| 2019年春   | 第一版     | 不支持       | RV32   | QEMU      | 不支持       | 小源&PQL            |
| 2019年秋   | 第二版     | 不支持       | RV64   | QEMU      | 不支持       | me                  |
| 2020年春   | 改进第二版 | 部分支持     | RV64   | QEMU      | 部分支持     | OS课程助教组        |
| 2020年春   | 第三版     | 不支持       | RV64   | QEMU      | 支持         | LyricZhao&Tuyixiang |
| 2020年秋   | 改进第三版 | 支持         | RV64   | QEMU/K210 | 支持         | me                  |
| 2020年11月 | 新版(目前) | 不支持       | RV64   | QEMU/K210 | 支持         | me                  |

在 PPT 上最好做成那种横轴是时间线，然后按照特性有若干条横线，每条横线都体现了该特性随着时间的变化情况。

时间轴的特定时间点向下拉一条竖线表示对应的版本。

同时，每一版的主要改进方向都有所不同。



于是为何要搞这样一个新版本呢？

准确的说是受到了编译实验改革的启发。

> 从第一个实验开始就是一个完整能运行的编译器，只是功能稍微简单一些。

原有的 OS 实验（指 $\mu\text{core}$）前面的章节直到进程为止，基本上每一个实验都是着眼于一个完整的系统中一个独立的子模块。比如两个著名的门槛：中断和页表。（话说 x86 的历史包袱可能比这两个门槛还要高）。在引入它们的时候，往往只能是通过使用 CPU 对应的特性，然后简单看看有什么效果。尽管会在那个时候就介绍一下它在实际 OS 中能起到那些作用，也并不容易被学生立即理解（由于没有例子显得比较苍白无力）。而对它们的真正使用往往已经到了数章之后，产生了比较大的割裂感。



rCore Tutorial 的定位一直是**用 Rust 从零开始实现一个运行在 RV 上的 OS**。虽然通过架构设计和文档支持有意加强了各模块之间的联系，实际上却并没有解决根本问题。

一个重要的着眼点：**简单**！需要用一个尽可能简单的例子来作为沟通理论和实践之间的桥梁。于是从一开始项目便致力于构造一个只是填充了最简单的算法（后续可以由读者自行替换成复杂算法）的骨架。而且，尽可能提供一些早期的功能验证和可视化。但是从现在的角度来讲，它仍然是被限制在最终成型的系统之内。然而算法简单这一原则倒是一直沿用到后来，而且也将被一直坚持下去（至少在实验的第一部分，也即 JUST DO IT 里面是这样。）



> 另一个重要的考虑：
>
> 做 lab 不要填空，而是要进行功能增强！（ref 小源）
>
> 这样说来，其实在 2020 年春季学期就已经不是填空了，虽然那个时候的功能还太过匮乏。



通过讨论，我们尝试像改革后的编译实验一样重新设计 OS 实验的章节结构。仔细想起来，现在的章节结构是和编译实验一样以应用为导向的，随着章节的推进，应用的需求逐渐复杂，对于执行环境也就是 OS 提出了更高的要求，于是就需要更加高级的抽象，于是自然而然也就需要 CPU 提供的各种能力。原先那种介绍 CPU 提供的能力，然后只是不明所以的简单用用可以说是全然本末倒置了。而编译实验可以看成随着章节的推进，PL 需要支持更多特性，然后再去倒逼编译器的进化，其实也可以看成是一种以应用为导向的框架。

> 其实现在 OS 实验好像比编译实验更平滑了？
>
> 因为它们都是：原版一开始需要有几章用来做出一个完整能运行的系统，后面是对这个系统进行补强。
>
> 编译器实验现在是 step1 直接完成了词法分析、语法分析等一大堆东西。
>
> 不过 OS 实验可能也没好多少...?
>
> 不管怎么样，开头的陡峭都是不可避免的。但是相对的，可以通过提升文档的质量来尽可能进行缓解。

## Tutorial 大纲总体介绍

适用于：

1. 做 lab 的同学可以更容易理解
2. 希望自己从零开始写一个 OS 的同学：相对理想/平滑的实现顺序

而且它是比较通用的，至少不区分 Rust/C 语言。

对于每一章而言，用户程序都是固定的（甚至细化到规定加载地址和运行顺序），只需要内核支持运行即可。

接口来说，确实需要区分一下到底固定的是系统调用接口还是用户 API。目前来看可能还是需要固定 syscall 接口，毕竟 rust 和 c 的标准库实现完全不同（虽然本质上差不多）。



然后就开始介绍大纲了！



这样的大纲有什么优点：

* 从明确的需求引入新的 CPU 特性，思路非常清晰
* 同时，每个新的需求基本上是纯粹的增量，对于已有接口的改动极少，基本上可以从头到尾写下来



后面插入一下已经在按照大纲做实验的同学和目前的进度。



## 分章节的重点概念和实现简要介绍

> 原则：如何让读者尽可能花更少的精力（众所周知，感兴趣的同学毕竟还是占少数）获取更多知识？那么就需要尽可能做到：
>
> 1. 更加形象化的文字描述，或者使用更多图示
> 2. 多对已有的知识进行比较、分类，这样只需要学习一个增量就能同时新旧知识产生更为深刻的印象。
>
> 这样，从方法论来讲，将一切都分解为最本源的元素就是一件很有必要的事情了。

这里的介绍需要遵循怎样一种格式呢？

1. 需要介绍应用的需求，可能还需要包括运行方式和顺序等。
2. 随后当然是介绍内核的实现，可能需要包括下面几个方面的内容
   * 需要提供哪些系统调用接口，实现需要做到怎样的程度？
   * 需要提供怎样的抽象，为此需要 CPU/内存/IO 怎样的能力？

OS 的精髓所在：异常控制流 Exceptional Control Flow

> 再细化的话，它应该算是 CPU 虚拟化或者所谓 CPU 多路复用的核心机制。而从 ostep 里面来看，OS 里面可能需要包含以下内容：
>
> * CPU 虚拟化
> * 内存虚拟化
> * 并发
> * 持久化（和高中时代提到的可持久化数据结构不是一个概念）
>
> 毫无疑问，CPU 的虚拟化可以说是其中最核心的部分，尤其是各种不同的控制流转移。
>
> 在控制流转移前后有一些寄存器需要保存，但其实只有符合两个条件的寄存器才会真正被保存：
>
> 1. 这个寄存器还会被当前的执行流所需要，或者说，至少还是有用的
> 2. 这个寄存器存在被覆盖的可能性

那到底什么是普通控制流呢？在我的理解里面，也无非就是顺序、分支、循环这三种控制结构（如果硬要说的还有 goto，但是在高级语言中很少看到了）。当然，还有一个函数调用 function call。其中三种经典的控制结构需要简单（姑且这样描述）的跳转指令，特征是不用考虑跳转回来。而函数调用却是需要调用的子函数返回之后从调用指令的下一条继续执行的。后面的话，就是对于函数调用与栈进行了非常深入的分析。我个人认为某种程度上这体现了程序的本质，对于 OS 的一些后续概念的展开也是必不可少的。

为何需要函数调用？这就涉及到编程的模块化，既能够减少代码体积，又能够方便编程。总之，函数调用已经成为必不可少的一部分。

我们暂且不提函数调用如何实现（注意这里面仍然有很多启发性的内容）。

无论如何，这里可以开始引入执行流的概念。（现在回过头来看，原来我这么有创造性的吗hhhhh）所谓的执行流，就是指限制在顺序、分支、循环、函数调用这几种控制结构之内的连续指令执行，伴随着它所能使用的资源的变化（包括寄存器、特权寄存器、以及栈）。而在某个固定时间点，执行流的状态体现在它所能控制的所有的资源在这一时刻的值。

执行流并不绑定到某个 CPU 上，它可以轮换在多个 CPU 上执行。

> 现在看来，恰恰只有这些是该执行流可以使用的“私有资源”，而全局数据段以及外设就是那些有可能产生并发冲突的公有资源。这个概念甚至可以一直延伸到后面的多核部分。
>
> 可以有一个相比执行流更加泛化的概念，比如每一个独立的函数执行。它们都有一部分空间来保存之前的执行的上下文。但这似乎并不是绝对的，异常控制流的情况就略有不同。

而异常控制流体现了执行流的切换。目前可能有两个不同的来源：

1. Trap

   主要是指原执行流切换到一条它由于 Trap 所派生出来的一条 Trap 执行流，中断和异常的情况略有不同

   此外，执行流切换对于原执行流几乎是透明的（特别是中断，异常的话，ecall 这种指令原执行流是有一定的预判的），因此客观来说切换回原执行流这件事情主要是由 Trap 执行流负责，Trap 上下文也是由 Trap 执行流保存在它的资源空间中的

   注意虽然原则上不允许中断嵌套，但是 Trap 是可以嵌套的，因此原执行流也可能运行在 S 模式

2. 任务切换

   这里一般是指两条应用程序执行流派生出来的 Trap 执行流之间的切换。它们之间的情况比较有趣，算是双方之间的协作，也就是双方都知道自己要负责哪些工作。从这一点上来说有些像函数调用了。

究竟如何实现这两种异常控制流是作为 OS 来讲需要着重考虑的事情，也是最基础的机制。

任务切换是并发所强调的事情。也就是在资源有限的情况下尽可能高效利用资源。某种程度上，并行算是和并发正交的，它只是研究如果手里有更多资源，如何能够做的更好。它们之间并不算矛盾。

### 第一章：RV64 裸机应用

执行流初始化/执行环境/应用程序的需求带来的不同层次的抽象

### 第二章：批处理系统

异常控制流I；异常

### 第三章：分时多任务系统

异常控制流II；时钟中断

> 外部中断：被分离到阻塞章节中
>
> 软件中断：被分离到多核章节中

### 第四章：内存隔离安全性

经 典 复 刻

MemorySet

MapArea

MapType

PhysAddr/PhysPageNum/VirtAddr/VirtPageNum 的封装和类型转换

特别是讲一下 FrameTracker 对于物理页帧的自动回收机制

另外也就是在这一章引入的内核动态内存分配，然后就可以开始用 alloc 库了，常用：Vec/HashMap/Arc/Box/Mutex

然后是仿照 xv6 进行内核和应用的地址空间隔离，这会造成 Trap 上下文的保存与恢复出现一些变化

没错，页表机制就是从这里来的

### 第五章：进程及重要系统调用

### 第六章：文件及进程间通信

文件抽象接口 File，对应于一个文件描述符

```rust
pub trait File : Any + Send + Sync {
    fn readable(&self) -> bool;
    fn writable(&self) -> bool;
    fn read(&self, buf: UserBuffer) -> usize;
    fn write(&self, buf: UserBuffer) -> usize;
    fn as_any_ref(&self) -> &dyn Any;
}
```

相比 C 来说更加灵活，以 xv6 为例，它需要将多种不同类型的 File 实现保存在一个结构体中。

```c
struct file {
  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe; // FD_PIPE
  struct inode *ip;  // FD_INODE and FD_DEVICE
  uint off;          // FD_INODE
  short major;       // FD_DEVICE
};
```

这里的 File 主要是和用户地址空间的一段缓冲区打交道，可以从缓冲区读到 File，或是从 File 写入缓冲区。

进程里面只需维护一个文件描述符表：

```rust
fd_table: Vec<Option<Arc<dyn File + Send + Sync>>>,
```

### 第七章：数据持久化存储

> 昨天看书看到的数据持久化的动机，主要可以分为三点：
>
> 1. 储存在内存中根本放不下的文件（剩下的两点想不起来了QAQ）
> 2. 持久化，也就是进程结束之后仍然可以访问
> 3. 数据可以被多个进程共享（其实 mmap 也可以？）

然后按照数据结构分层的话，至少 easy-fs 里面是分成如下几层的：

最底层是抽象接口 BlockDevice，在 easy-fs 中并没有具体实现，而是暴露出来让库的调用者来实现，实现之后就能使用库顶层的 Inode 

上面是块缓存 BlockCache，由于可能有两个数据结构位于同一个块中（没错说的就是你 DiskInode），所以使用块缓存反而能比较方便实现，在目前的闭包实现之下，无需经常强制写回。

接下来是被 Dirty 包裹的各种磁盘数据结构，比如 SuperBlock/DiskInode/Bitmap要么就是简单的数据块。

> 使用闭包的有趣写法

然后是文件系统的实现 EasyFileSystem，它主要负责管理两个 bitmap 进行分配回收等等...?

最上层是 Inode



当然，在 OS 我们还需要将 Inode 封装成 OSInode 来维护它的 readable/writable/offset 信息。



值得一提的是，打包程序 mkfs 也是给这个库实现了块设备来实现的。

## k210 多核移植

伟大的 RustSBI 出场了！

这里可能主要介绍一些遇到的 bug 和解决方案。

1. 清空 bss 清空栈

2. 当原子指令在 bss 的时候，初始化同步可能失败

   解决方案：使用 IPI

3. icache

4. 外部中断

## 目前实现的一些不足之处

## 心得体会

## 未来展望





