终于可以筹备终极的第九章代码辣！好耶好耶！

然而想想的话似乎并不太简单。

## xv6设备中断分析

需要注意的是，能否/如何在设备工作时继续提交请求，这将有助于降低响应延迟。

外设的访问方式是：在系统调用的时候首先获取对应外设的自旋锁，在提交完请求之后调用`sleep`，而后通过`wakeup`唤醒

xv6里面`sleep/wakeup`的设计比较有趣，稍微记录一下：`sleep`有两个参数，分别是等待资源的指针（被称为一个channel）和调用`sleep`时最后获取的锁的指针，调用`sleep`会将资源指针记录在TCB之内，释放最后获取的锁并完成任务切换。而在切换回来之后会重新获取锁并返回，这时资源已经就绪可以继续执行了。这也就意味着，调用`sleep`的时候调用链更上面的锁都是没有被释放的。然后`wakeup`只有一个参数就是等待资源的指针，它会遍历所有阻塞状态的TCB，如果等待资源与传入参数相同则将其唤醒。这个对应到我们Rust的实现其实就是每个资源一个条件变量，条件变量里面是一个等待在它上面的任务队列。那么锁应该如何对应呢？如果不考虑`sleep`函数的话，那么访问外设的流程的话，假如是单个请求就直接获取锁，提交请求，释放锁，然后切换出去。等到切换回来的时候再重新获取锁就行了，其实本质上和`sleep`是一样的。

至于为什么要循环调用`sleep`，大概想到了之前的一个东西，就是Hansen/Hoare管程，后者是唤醒其他进程后立即切换过去执行，而前者则是当前进程优先执行，哈哈这个不是完全没有关联吗？循环的目的应该是为了避免进程被唤醒并切换过去之后，唤醒的条件又不满足了（这是完全有可能的），这时只能继续等待了。

然后顺带看一下virtio-blk的中断处理：首先获取该设备整体的锁（对应到Rust里面就是一层对全局变量的Mutex或者UPSafeCell包装），从对应的ringbuffer中找到相关的缓冲区地址，并将其作为channel传给`wakeup`唤醒相应进程，最后释放设备锁。

所以会想到一个问题，就是设备锁要类似C风格嵌入在结构体内部还是作为一个wrapper。这个大概很自然的想到将每个设备整体开一个struct，struct里面包含一个条件变量，然后将struct整体上锁。这样锁的粒度可能会有点大，但应该没啥问题。

另外，让我有些不解的是xv6的文件系统为什么会有那么多把锁，因为只要最上层上锁的话其他进程应该都进不来啊。

---

后面是xv6的PLIC设置：PLIC起始地址为`0xc00_0000`，然后virtio和串口的irq id分别是1和10。将两个中断源的priority设置为1，然后将每个hart的S enable的两个中断源的位置设置为1，将hart自身的S中断阈值设置为0。如果在RustSBI中没有对PLIC进行额外设置的话，这就能保证设备中断为S态了。当然需要在RustSBI中设置的是中断代理mideleg。在处理中断的时候，首先读取hart自身的s claim，按照读到的irq ID相应处理，然后将同样的irq ID写回到hart自身的s complete。

xv6每个核都能处理中断，想想这似乎也是理所当然的。

## rust嵌入式代码分析（考虑常量泛型）

## `rCore-irq-test`代码分析

