## 摘要

* 将 Linux 作为一个单内核架构的代表，与 Zircon (代表微内核) 进行对比
* 比对方面主要在操作系统的基本概念，以及驱动程序的实现和性能
* 内核架构几乎不会影响驱动程序的实现，尽管它对操作系统有着部分影响
* 然而，通过实验发现微内核的驱动程序性能相比单内核有所下降
* Zircon 相比 Linux 在驱动开发的一个明显的好处是去除了历史包袱
* 工作主要针对有志于进一步优化已有内核的系统或驱动开发人员

## 1. 引言

* OS 的一种功能：充分利用多核、内存、I/O 的算力，同时要具备一定安全性
* 核心任务：安全、公平的将物理资源分配给多个进程，该任务通常由操作系统中的**内核**来完成。但至少在 Linux 中，内核与 OS 之间的界限并不清晰。有人提出*进程管理、内存管理和基础 I/O 操作*由内核负责。但其实这是因设计而异的。但是大多数至少还是将**驱动模块**纳入内核。
* 微内核->Fuchsia，单内核->Linux
* 学习 Zircon 的意义
  * 不同于以往取得成功的 microkernel 如 QNX 或 FreeRTOS，Zircon 并不兼容 POSIX，这是一个大胆的设计
  * Zircon 使用 C++ 开发
* Linux->Android，社区开发，继承 Unix，微内核理论更好但性能不佳
* Zircon 也专注于移动/嵌入式领域

### 1.1 实验目标

* 比较单内核 (monolithic kernel) 和微内核 (microkernel) 架构上的不同以及它们如何影响驱动程序的开发(不包括文件系统)
* 论文主要内容
  * 现代操作系统主要概念以及在 Linux 和 Zircon 中如何实现
  * 评估单内核和微内核对于驱动程序开发的影响
    * 驱动程序模型分析以及它们如何集成到内核中
    * 在例子的帮助下评估驱动程序开发本身
    * 观察驱动程序开发工作流，特别是注意在过程中使用的工具
    * 思考驱动程序如何被内核使用
  * 基于理论概念以及 Linux 和 Zircon 的开发时间线分析实验结果

## 2. 现代操作系统概念

### 2.1 操作系统架构

* 架构设计的选择取决于要解决的问题
* 大概的指标可以分成以下几种：高可用(reliable)，可移植性(portable)，可拓展性(scalable 指合理利用多核资源，extensible 只内核功能易于拓展)，实时性(real-time)，高效实现(efficient)，用户态应用安全性(secure)，可维护性(maintainable 指 policy 和 mechanism 的分离，这两个术语是在 OS 中特有的，大概可以对应于问题 what 和解决问题的方法 how)

**用户态、内核态**

* x86 规范中 ring0~3 各自的作用，但 Linux 仅用到 ring0 和 ring3，系统调用 ring3->ring0
* CPU 当前所处特权级用 PSW 寄存器来表示，它是 per-Core 的(如 ARM 架构中的 CPSR 寄存器)

#### 2.1.1 单内核架构

* 单内核：一个各模块之间没有任何内存保护或检查，可以无任何限制互相访问的大二进制程序，全程在内核态下运行，对于 I/O、时钟、中断、甚至内存有着完全的访问权限

  > 优点：没有一些不必要的通信，性能较高
  >
  > 缺点：一旦其中一个模块崩溃整个系统都会崩溃；不够安全

* 单内核的优化——模块化操作系统：可以动态加载/卸载一些功能模块

  * 要说明的是，功能模块也会被加载到内核态下运行，它的崩溃也会导致系统的崩溃，但是性能也会比较高(由于没有用户态和内核态之间的通信)
  * 但是，这样做一定程度上减小了内核的容量，提供了一定的灵活性和安全性，在 Linux 和 Solaris 中均得到了使用

#### 2.1.2 微内核架构

* 要解决的问题：单内核结构难以维护，即使引入模块化也会带来系统崩溃的风险
* 方法：将一些功能放到内核之外，移动到用户态，达成良好的机制与策略的分割，不动内核就能修改用户态实现的策略
* 究竟什么放到内核中尚无定论，但得到广泛认可的是**进程调度**和**进程间通信**，而内存管理与虚拟化、设备驱动或同步机制是否放到内核中存在争议
* 各模块以用户态进程的形式工作，借用内核提供的 IPC 机制进行通信
* 仍满足用户态、内核态限制，用户态驱动需要请求内核访问各种硬件资源，这带来以下优点：
  * 内核有权限检查请求是否安全，内核更加可靠、安全；
  * 驱动(单个模块)的崩溃不会影响整个 OS；
  * 易于移植
* 为何目前微内核仍然主要用于实时系统、军事(等需要高可靠性的环境)而非桌面系统的主要原因在于性能低下，不仅仅在于大量模块处于用户态带来的大量上下文开销，还有这一过程带来的高 cache miss 率
* 值得一提的是，微内核的 L4 通过高性能的 IPC 使得总体性能接近 Linux，但目前绝大多数微内核系统都主要用于高可靠性环境，如 Integrity, QNX, seL4 等

#### 2.1.3 分层架构

* 将内核分成若干层(或形象的描述为若干同心圆)，自下而上(或从里到外)权限依次下降，提供的接口愈加复杂，但是各层的接口与功能如何划分是一个问题，且由于层数较多，系统调用的性能较低
* 一般来说分层架构主要出现在单内核中，但是这种思想也逐渐出现在微内核架构中，下面列出了部分例子

#### 2.1.4 混合架构

* 混合架构包含了微内核、单内核以及分层架构的优点，在对标单内核性能的同时也希望得到微内核架构的优良模块化及可靠性

#### 2.1.5 Linux 的单内核架构

* 由于是宏内核，不存在权限级屏障(privilege barrier)

* 从代码结构上可以看出，Linux 主要解决 5 部分任务

  * 进程管理
  * 内存管理
  * 文件系统
  * 设备管理
  * 网络

  代码做到了某种程度上的模块化
* 比较底层的汇编代码依赖 GCC，目前出于代码可维护性和可读性减少汇编代码的复用，这也能减轻对于 GCC 的依赖


#### 2.1.6 Zircon 的微内核架构

* Zircon 从 Little Kernel 的一个分支演变而来，但有不同
  * Zircon 针对高性能设备(因此仅支持 64 位架构)，一等公民用户态支持，安全模型
  * LK 针对嵌入式设备，作为 Android 的 bootloader 并为 Android 提供底层的运行环境，支持 32 位架构
* Zircon 作为微内核架构拥有良好的安全性、可靠性以及模块化
* Zircon 并不像 POSIX 一样将各种 I/O 操作以及进程管理作为核心任务进行优化，事实上 Zircon 仅适配 POSIX 的一个子集
* Zircon 运行在内核态的内核放在 *kernel/* 目录下，运行在用户态的服务、驱动、用户库放在 *system/* 目录下
* Zircon 的内核部分提供以下基础功能
  * 进程管理
  * 虚拟内存管理
  * 进程间通信
  * 同步互斥机制
* Zircon 主要由 C++ 实现，少部分代码由 C 实现，为设备驱动提供了 C/C++ 语言的原生支持；但同时 Zircon 还提供了一种接口定义语言(IDL，Interface Defination Language)为进程内驱动定义了规范，也支持其他语言
* Zircon 同时支持 GCC/Clang 编译器

### 2.2 系统调用

* POSIX 只是定义了用户与内核态交互的 API 而不是系统调用，通常是以用户库(如 libc) 的形式
* POSIX 在 Unix、macOS、Mach、Linux 上均一定程度上支持

#### 2.2.1 Linux 系统调用

* 没啥好说的

#### 2.2.2 Zircon 系统调用

* 在 Zircon 中，系统调用属于**句柄**这一概念，该对象可以将用户态应用指向一个内核对象
* 每触发一个系统调用，内核都会句柄进行权限检查，安全起见将检查下述内容
  * 句柄和系统调用有着匹配的类型；
  * 句柄的参数参考发起系统调用的进程内部的句柄列表；
  * 句柄有着足够的权限发起系统调用中的请求
* 与 Linux 不同的是，Zircon 仅提供一个系统调用与 C 接口的共享库 *libzircon.so* ，它是一个由内核直接提供的虚拟动态共享对象（vDSO, virtual Dynamic Shared Object），而并不是以 ELF 文件的格式存储在磁盘上。由于用户态和内核态都可以访问 vDSO，而不必进行上下文切换。因此， vDSO 是 Zircon 上进行系统调用唯一的方式，也是微内核架构性能问题的一个优雅的解决方案。
* 系统调用是通过一个抽象定义语法以及一个名为 *abigen* 的匹配工具来定义的，这个工具可以为 *libzircon* 和内核的系统调用实现生成头文件和代码。
* Zircon 仅实现了 POSIX 的一个很小的包括基本 I/O 操作以及 pthread 的子集，并不支持 Unix-like 的信号、符号链接等。*libzircon.so* 不能直接进行 I/O 操作，他们是通过覆盖了 *libzircon.so* 中的一些弱符号的 *fdio.so* 来调用的。

### 2.3 进程与线程

### 2.4 同步互斥与 IPC

### 2.5 调度

### 2.6 内存管理

### 2.7 I/O



## 3. 比较 Linux 和 Zircon 驱动程序开发的不同

## 4. 结论

## 5. 展望

