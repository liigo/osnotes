> 能够将下面的概念串在一起进行深入阐述？
>
> 基于中断和轮询的设备访问有何区别？中断和轮询的方法论仅限于访问I/O外设吗？
>
> 如何将中断/抢占/调度结合成一个有机的整体？
>
> 上面的调度似乎仅限于CPU资源，但是能否进行拓展？
>
> （全书）强调OS的资源管理器视角。事实上这不仅限于OS，我们需要对我们所管理的资源更加了解，知道其使用方法和一些限制才能更好管理和调度它们。首先是一些硬件资源：CPU可以分成单核和多核视角，涉及到指令的执行，常见的资源分配单位是时间片，如果细化的话需要考虑到CPU内部的寄存器、各种多级缓存还有总线。内存资源要从不同的抽象级别来展开，物理内存视角可以看到页表和其他剩余物理内存，它们可以抽象出地址空间，在地址空间内部可以分成不同的数据段，具有代表意义的是数据区域的栈、堆还有静态区域。在这之外就是I/O外设和外围总线了,各种外设间有很大的不同因此这里不展开讨论。其次是一些软件（或者说逻辑上的）资源，比如共享变量、文件系统中的文件等等。不过似乎它们都可以通过RAII归结为存储系统中的共享变量。资源的不同类型、以及每类资源的复杂程度均是随着应用的需求而不断推进的，因此并没必要一开始就要求过于深入的认识。
>
> 当速度不匹配时，需要涉及到缓冲区。

目前算是对于很多事情有了一定的理解了，那么终于可以来构想一下单核同步互斥的章节需要包含一些什么内容了。

首先明确一下同步互斥的概念。同步指的是多个实体（如线程）在合作完成一项任务时在时序上存在的依赖关系。比如两个进程通过管道通信，那么在写者向管道写入数据之前，读者完全没有向下运行的必要。另外一个例子是让一个进程睡眠一段时间，事实上可以看作是计时器和进程之间的合作。这个例子值得展开的地方有很多。首先，合作的实体的类型可能完全不同。这里的话是计时器和进程。计时器涉及到的资源只有它自身，这是一个极其简单的硬件，它可以被认为是自身不断在轮询。而进程的话需要绑定到CPU上，还需要访问内存才能运行。（CPU最神奇的一点是能够进行上下文切换）睡眠最朴素的实现就是在进程中轮询直到超时。可以看到，这里只是进程单方面在访问计时器，大量的轮询浪费了CPU资源（注意进程的运行是绑定了CPU的，无论是U还是S特权级）。但实际上这些轮询本是不必要的，因为计时器本身就在不断地轮询了，那么为什么CPU还需要轮询呢（这里最大的问题可能是其他的进程完全不会推进度）？为了避免浪费过多的CPU资源，我们之前的实现是如果没有超时就先切换出去，等到切换回来的时候再检查是否超时。但是这样的话，进程向下走的时间点为超时后首次被调度到的时间点，取决于调度情况可能会产生很大的响应延迟。

但是如果引入一项额外能力：计时器可以通知CPU——也即时钟中断的话，仔细思索了一下，以往的实现：即进程加入阻塞队列，添加一个新的计时器，每次时钟中断的时候将所有超时的计时器对应的进程重新扔到就绪队列的做法延迟也不见得很低（当然我们可以直接丢到队头，但是有可能出现饥饿），毕竟我们并不是在实现一个RT系统。尽管延迟不一定优化，但是CPU开销确实能够做到最低：因为在条件满足之前睡眠进程完全不会被调度到，这能够减少大量的上下文切换开销，其中最为重要的是避免了缓存抖动现象。这也就是本章的重点——阻塞了，这个后面还会展开的。另外再小小的插入一句，由于计时器比较特殊，CPU其实还是是在做轮询，当然大部分轮询都是为了进行时间片划分，仅有少部分中断与计时器相关（理想情况下计时器应该可以设置多个超时时间，但是在RV上我们只能设置一个，当然如果实现精细的话还是能够大幅提升计时精确度的），它只是轮询频率大幅降低，相对CPU总资源而言占比极少而已。

接下来便是互斥。当多个实体进行合作的时候，其中或多或少会涉及到一些共享资源。在对资源进行访问的时候，需要保证访问操作在时间上两两分隔开来，也即所谓的串行化。其中最典型的便是线程间的合作需要共享内存。我们不妨回顾一下Go语言的核心哲学：“不要通过共享内存来通信，而是通过通信来共享内存”。其思路大概是线程之间可以接受或发送一些token，token中保存了共享变量的引用，拿到token的线程便视为对于该共享变量有了独占的访问权限，在访问之后，线程可以将该token交还给资源管理器或者直接传给其他线程。但是这有一个问题：通信其实也是一种同步手段，那么它又是如何实现的呢？其实不难发现它也需要基于底层的互斥原语来完成同步。不过它的意义是？也许比锁更加轻量级？这个就不太清楚了。

---

同步互斥（单核）的下一步规划，由于目前手头没有电脑就先从这个备忘录开始吧。之前我们已经分析过同步和互斥的概念，那接下来就是如何把这些概念通过实际的例子展现出来。

大概可以分成这样两个方面：单核上有哪些可用的同步互斥原语（这里不做区分，因为很多原语兼具这两个功能），以及利用它们可以解决哪些问题。

ucore里面提到的同步互斥的底层支撑是定时器、关中断和阻塞队列。其中中断+阻塞是一种经典的同步原语，它需要内核调度器的支持以及CPU对于中断的支持。相比朴素轮询和yield加轮询，它可以显著提高CPU利用率。这里的中断也许可以泛化为软件或硬件意义上的一种信号，软件信号如写者在管道中写入数据之后需要通过内核间接唤醒读者、又比如内核中的kill信号等；而硬件信号就是中断，这个就是负责发送信号的是硬件，如时钟中断（来自定时器）和外部中断（来自各种IO外设），也许我们归结为信号加中断会更好。再总结一下它的总体流程：一个任务发现自己需要某些条件满足才能继续向下执行，于是内核将其阻塞（阻塞队列可以看做阻塞机制的具体算法实现），随后被等待者发送软件或硬件信号被内核捕获到，从而唤醒之前等待的任务。

那可以和我们之前的纯轮询以及轮询加yield做一个对比。目前仅考虑单核。单核情况下，纯轮询会浪费大量时钟周期，而且如果等待的是软件信号可能出现由于已经占用了处理器而永远接收不到信号的情况。如果有yield的话，这会带来大量上下文切换开销，且如果维持原有调度算法的话，信号处理的延迟不可预测。

实际上，即便引入中断加阻塞，也不仅仅是加上一个阻塞队列即可。我们确实还需要基于优先级的抢占机制。

