这篇[C++的值类别](https://paul.pub/cpp-value-category/#id-perfect-forward)的文章写的很好。

突发奇想来看C++，主要是想对比一下C++和Rust的内存模型。

最开始，C++里面的值类别（category，不同于类型即type）只有左值和右值两种，左值“有身份”，也即它被保存在一个较为稳定的地址上；而右值通常是指一些临时存在的常量或变量，在我的理解中，它“不稳定”，程序员不应假定或依赖于它们的位置。

自C++11之后，大概是出于移动语义的需要，可将所有的值类别按照是否有身份，是否可移动进行区分。

有身份的值类别被称为glvalue，其中不可移动的称为lvalue，可移动的称为xvalue；

可移动的值类别被称为rvalue，其中有身份的被称为xvalue，没有身份的称为prvalue。

移动语义区分于传统上的拷贝语义，拷贝语义包括常见的拷贝构造函数和拷贝赋值运算符。当我们使用它们来构造或初始化一个新的变量的时候，会将原先的变量拷贝一份。这会导致两个相同的值同时存在，如果值类型为原生类型没有什么问题，如果值类型包含指针的话就会有各种各样的问题，Rust已经教过我们很多了。这个时候最好的主意是进行移动（move），把值直接移动到新的变量中。

于是这里就涉及到左值引用和右值引用。左值引用分为const引用和非const引用（如`const int&`和`int&`），右值引用则类似`int&&`。右值引用引用的是生命周期即将结束的左值（即将被移动到其他变量中）或是临时值，如果是临时值的话则可以短暂延长临时值的生命周期到右值引用的生命周期结束。不过更为常见的用法是移动构造函数和移动赋值运算符，与拷贝语义的版本相对，它们接受右值引用作为参数而非左值引用。在实现中我们要确保输入变量的值完全被移动到输出变量中。也许在一个变量的值被移走之后，编译器将会像Rust一样禁止对它的后续访问？

另一个特性则是完美转发(Perfect forward)，这个看上去很复杂所以暂且跳过。

---

顺带一提，C++里面的智能指针`std::unique_ptr/shared_ptr/weak_ptr`对应于Rust中的`Box/Rc/Weak`。它们是否线程安全还不清楚。