# 1unsafe

有些时候必须了解 Rust 深层的工作机制，不仅是为了性能，有时还会关系到正确性（比如和硬件打交道、实现操作系统、或者是调用其他语言的接口）。

当实现细节开始在一门安全的编程语言中被考虑的时候，程序员通常有以下三个选项：

1. 请求编译器/运行时进行底层优化
2. 对于需求套用一种不地道且不优雅的设计
3. 换用另一门编程语言重写

如果选择最后一种，大多数情况下是用 C 重写（C 更加通用）。但是 C 极其不安全，而且这种不安全性在和其他语言合作的时候会被放大。必须特别注意保证 C 和其他语言都知道各自的情况而不会互相下绊子。

那么如果必须用 Rust 重写呢？Rust 其实可以看成 safe Rust 和 unsafe Rust 两门语言的组合。使用 safe Rust 永远不需要担心类型安全或内存安全问题，而在 unsafe Rust 中我们做很多不安全的事情。实际上，在标准库的帮助下，仅使用 safe Rust 就能实现很多高性能的程序或者库。

但是，也许你需要和另外一门语言打交道；也许你需要一个标准库未曾提供的底层抽象；也许你在编写一些 Rust 类型系统无法理解的代码；甚至也许你在写 Rust 标准库。这个时候就需要用到 unsafe Rust 了。

unsafe Rust 和 safe Rust 有着相同的规则和语义，它只是允许我们做一些被编译器认为是不安全的事情。

本章的意义在于告诉我们 Rust 可以获得和 C 一样的底层掌控能力，但是又能避免在其他安全语言中这样做所带来的很多问题。但是其实还有很多问题。我们必须意识到 Rust 的类型系统所假设的一些特征并且在任何和 unsafe Rust 打交道的代码中检查它们。所以我们要了解它们是什么以及如何管理它们。

