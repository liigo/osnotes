## 2020-09-24

Rust 当中只关心位置和值。除非与 trait object 相关，否则不会用“对象”这个术语。

Rust 的很多内建类型均标记为 `Copy` trait。标记为 `Copy` 的类型在按值传参、赋值的时候会取复制语义，可以理解成将一块内存原样复制到另一个地方，并通常绑定到不同的名字下面；否则，通常为了保证值不能出现多次或是有一些限制，在按值传参、赋值的时候会取**移动**语义。它大致可以分成两个阶段：前一阶段和 `Copy` 一致，后一阶段则是要在编译器层面 invalidate 掉被移动的变量，禁止它再被访问。那么被移动的变量对应的位置又该何去何从呢？这个问题暂时难以得出结论。

另一个问题是，对于自己创建的类型，`Copy` 和 `Drop` 不能并存。这可能是因为，标记为 `Copy` trait 的类型，和一段固定大小的空间没有什么区别。而未被标记为 `Copy` trait 的类型，由于它被限制为只能取移动语义，往往在释放的时候都不是直接扔掉那一块空间了事即可，而是要有一些相应的处理。

一个强大的[链接](https://zhuanlan.zhihu.com/p/189694498)

## 2020-09-25

上面的经典文章，提到了位置和值的概念，按照我的理解，位置就是指一块内存（无论是全局数据、堆、还是栈），而值当然指的是这块内存中保存的内容。

**位置**

一个位置可能有以下的五种状态：

1. 位置存在，但里面还没有值；
2. 位置存在，且里面也有值；
3. 位置存在，里面曾经有值，但现在被移走了；
4. 位置存在且有值，正在被共享借用（多个不可变借用）；
5. 位置存在且有值，正在被独占借用（单个可变借用）。

我们分别重新叫做未初始化、有值、deleted、&、&mut 状态吧。

状态只是位置的第一重属性，他还具有其他属性。

比如位置的类型属性，包括类型大小、内存对齐以及析构方法，还有一些标记。当一个类型被标记为 `Copy` trait 的时候，与该类型相关的位置就不存在 deleted 状态。事实上，将自定义的类型标记为 `Copy` 之后，无法再为其实现 `Drop` trait，其中的原因我昨天尝试分析了一下。

还有位置的可变性属性（w: 大概可变性放在位置这个层面而不是变量这个层面会更好一些）。当没有 mut 的时候，一个位置就不能位于状态 &mut，且离开了未初始化状态之后，里面的值不能发生变化。

位置的来源：通过定义变量、函数参数、返回值均可生成带名字的位置，变量可以视为**名字与位置的绑定**。此外，还有一些隐式的临时变量也会有对应的位置，只是我们无法显式访问罢了。

**值**

类型决定了值的内存布局。

Python 和 Java 这类语言提供值的运行时管理器，而 Rust 一切都在编译器中完成。

**观测交互**

打印一个位置的地址会引发编译器关于内存分配策略的变化。

**赋值(assignment)**

Rust 的赋值机制相比其他语言有很多不同。

假设 a,b 两个位置有着相同的类型，我们想要实现 a = b(即 a 为目标，b 为源)

在编译的时候我们需要依次检查：

1. 若 a,b 处于 & 或 &mut 状态，它们将在这一瞬间回到有值状态。这也就意味着所有关于它们的引用不能在这之后继续存在，编译期的借用检查器会帮我们检查是否产生生命周期冲突。
2. 若位置 a 处于有值或 deleted 状态，且位置 a 并不是 mut 的，报错；
3. 若位置 b 处于未初始化状态或 deleted 状态，报错。

这里我写了一段代码来验证第一条：

```rust
fn main() {
    let mut p1 = Person { v: 10, };
    let rp = &p1;
    let p2 = Person { v: 11, };
    p1 = p2;
    println!("{:?}", *rp);
}
```

会报出编译错误：

```rust
error[E0506]: cannot assign to `p1` because it is borrowed
  --> src\main.rs:15:5
   |
13 |     let rp = &p1;
   |              --- borrow of `p1` occurs here
14 |     let p2 = Person { v: 11, };
15 |     p1 = p2;
   |     ^^ assignment to borrowed `p1` occurs here
16 |     println!("after world!");
17 |     println!("{:?}", *rp);
   |                      --- borrow later used here
```

我敢说如果是 C 语言这样肯定没有问题。

这告诉我们，借用是对于**值**的借用而非对于**位置**的借用。注意下面的运行时步骤，若没有被标记为 Copy，实际上 p1 里面的值在运行时第一步已经被销毁，在值被销毁之后，之前的对于它的借用 rp 也就失效了。而我们又尝试去访问它，即在编译期发现了借用错误。

注意，即使将 `Person` 标记为 `Copy` 该问题也同样没有得到解决，不能通过编译。

但是 p2 的情况则稍有不同。若 p2 被标记为 Copy 的话，p2 位置里面的值其实不会受到影响，因此跨越它的借用不会出现问题；但反之，p2 位置里面的值需要被 invalidate，由于借用是对值进行借用，就不行了。

所以在我看来，原作的说明不太完整。已经提出评论了，期待和 dalao 交流一下。

运行时步骤：

1. 如果 a 处于有值状态，且类型不是 `Copy` 的，那么**对于 a 里面的值进行析构**，从而进入 deleted 状态；
2. 将位置 b 里面的值按位复制到位置 a 中，位置 a 进入有值状态；
3. 如果类型不是 `Copy` 的，位置 b 进入 deleted 状态。

(w: 这样看来的话，一个位置处于未初始化和 deleted 的状态虽然都不能访问，但是报出的错误却应该是不同的。)

**所有权到底是什么**

感觉一下子懂了好多东西，明天再继续来看，[here](https://zhuanlan.zhihu.com/p/201220495)。

## 2020-09-28

原作者对文章进行了修改，在编译器在赋值时候对源位置的借用检查，确实需要考虑到类型是否为 Copy。

此外，原作者否定了我说“借用是对值的借用而非对位置的借用”的说法。实际上，借用是对“**有值的位置**”的借用。值不能脱离位置而存在。最典型未实现 `Copy` trait 将源位置的值 move 出来的情况，实际上是源位置进入了 deleted 状态，所以它不再是一个"有值的位置"，故此引用失效。目标位置在被赋值的时候也会短暂进入 deleted 状态，从而将先前对它的借用无效化。

## 2020-10-05

抽一点时间继续来看经典文章。

Rust 中的所有权模型实际上是没有我们之前构想的位置-值模型精确的。若从位置-值模型来理解所有权的话，大概也就是需要做到 `move` 语义的正确实现，以及在适当的时间点销毁位置和里面可能的值。如果是从源码级的角度来理解，一个变量通常绑定到一个位置上面并拥有其所有权，在变量的生命周期结束后负责销毁对应的位置。严格来说每个位置都应该被一个变量所有。但是变量里面包括编译器为我们生成的一些临时的匿名变量，我们是没法通过它们直接来访问对应的内存的，而只能通过间接的方式。比如我们不会为链表上每个节点都开一个变量，而是只保存它的表头。这样的话，链表的一切操作都只能从表头发起，我们没办法单独回收一个中间节点。

回头去看了一下生命周期参数。其主要的目的是符合借用规则，即输出引用不能 outlive 输入引用。如果一个函数没有输出引用的话，其实输入引用没必要加入任何生命周期泛型。生命周期泛型是一个泛型，会在编译期调用函数的时候将泛型单例化为具体的生命周期。最关键的检查就是与输出引用有关。生命周期泛型限制，如 `'b: 'a` 在编程之道书中提到的 `longest(a: &'a str, b: &'b str) -> &'a str`，这里的限制是指输入的 `'b` 包含 `'a`，或 `'a` 是 `'b` 的一个子集。这样的话才能不违背借用规则。如果没有输出引用，各个输入引用可以随意命名为相同或不同生命周期参数，互相不影响。 

重新从 `std::thread` 的角度来考虑 `Send` 和 `Sync` 的问题。为何 `Rc` 未实现 `Send`？`Send` 意味着可以安全的转移所有权，从 `move` 语义来讲就是说值从一个栈按位复制到另一个栈，并 invalidate 原来栈上的那个变量。但是按位复制该变量的时候也需要经历多条指令。如果在 `move` 到另一个栈的过程中，另一个核访问了另一个 `Rc`，就会产生问题。而 `Arc` 可能是利用原子指令来实现类似于无锁数据结构，这种并发访问就不会出问题。

## 2020-10-10

之前提到闭包的时候想到了，现在记录下来。其实闭包和 Future 在某种程度上比较相像，都是编译器自动为我们生成一个结构体并实现 `Fn, FnMut, FnOnce` 中某个 trait，它关键的变量捕获功能其实就是把当前作用域待捕获的变量以引用或者转移所有权（类比直接传参，取决于类型是否实现 `Copy` trait）的形式保存在结构体的 fields 中。这样听起来的话，的确可以称为一个闭包（Closure）了。可以发现调用它的时候无需传参，且无论在任何地方都可以调用。

现在在回顾 zCore 里面的异步 OS 设计模式，里面用到了大量的 Rust 函数式编程，所以去回顾一下闭包和迭代器。

闭包可以从当前上下文中捕获变量并储存在编译器自动生成的结构体中。一共有三种不同的捕获方式：

`FnOnce` 消耗闭包里面用到的变量，并将其所有权转移到闭包环境之内。因此它只能被调用一次，不然会出现 moved value 错误。 

`FnMut` 以可变引用的形式捕获闭包里面用到的变量。

`Fn` 则是以不可变引用的形式捕获闭包里面用到的变量。

捕获的时机是在闭包被声明的时候，也就是匿名结构体被构造出来的时候。

当然，除了捕获的变量之外，我们还可能传一些参数给闭包，这些内容共同构成了闭包的执行环境。闭包可以捕获变量，可以在另一个环境下调用，更加灵活，但是相比函数调用有一些内存和所有权转移开销。

`FnOnce, FnMut, Fn` 更像是一种标记，可以在闭包作为参数的时候对闭包的捕获方式进行一些限制。比如如果类型为 `FnOnce`，那么捕获的变量可以以转移所有权、可变/不可变引用的方式捕获；如果类型为 `FnMut`，那捕获的变量就只能以可变/不可变引用的方式捕获；如果类型为 `Fn`，那就只能以不可变引用的方式捕获。

编译器会分析我们对于每个环境变量的捕获方式，所有权转移/可变引用/共享引用都有可能。通过 `move |...|` 可以强行将闭包里面用到的所有变量都进行所有权转移。但是这取决于变量的类型，如果被 `Copy` 标记的话并不会进行所有权转移，而只是会在闭包结构体里面复制一份。

比如下面的代码就不会有问题：

```c
fn main() {
    let x = 3;
    let p = move || { println!("{}", x) };
    println!("x = {}", x);
    p();
}
```

目前看来，如果将一个闭包作为参数，很有可能是传进去的那个环境有闭包所需的参数，然后就直接在那个环境跑闭包了，或者是将闭包进一步包装留待以后使用。

一句题外话是，如果想给一个结构体 derive `Copy` 需要先 derive `Clone`。一般情况下来讲 `Clone` 应该是深复制，大概率导致其拷贝从二进制的角度来说是不同的；而 `Copy` 的行为则是在赋值/传参/捕获过程中发生的完全的按位复制。这样，这种“连 `Clone` 都不支持更别提 `Copy` 了”的机制倒是也有一定的道理。

## 2020-11-16

过了一个多月？今天结合着 cs242 和 cs110l 总算有点弄懂了 Send/Sync 是怎么回事。

这一切都回归到一个经典问题，为何 Rc 不是 Send 的呢？

并发冲突可能有两个来源，一个是全局数据，另一个则是通过闭包的捕获将一个线程（栈）上的变量分享给另一个线程，这个应该只有在 thread::spawn 的情况下才会出现，其他情况下我想不到 rust 还能如何区分两条执行流。因为函数调用（即使有闭包的存在）的话也始终是在一个栈上。所以 no_std 应该是不会有这种情况的。即使是 Future，那好像也始终在一个栈上。在 thread::spawn 通过 move 捕获，需要的应该是 Send；通过引用捕获，需要的则应该是 Sync。

Rc 的实现是一个胖指针，里面有两个裸指针分别指向堆上的引用计数和实际的值，也可以把它看做就是一个指针。当我们将其 move 到另一个线程（很有可能是在栈上）的过程中是不会出问题的，这也是我误认为 Rc 也是 Send 的原因。因为 move 之后原线程就失去所有权不能访问了，至少在 move 过程中不会有并发冲突，可以安全完成按位复制。但 Rust 实际关心的是 move 之后怎么办，这样 move 之后，是有可能两个线程同时存在指向堆上同一个位置的 Rc 的。而 Rc 修改引用计数并不是原子的，如果两个线程同时修改就炸了。Rust 某种程度上有点一刀切，它看到你 thread::spawn 闭包 move 捕获的类型不是 Send 的，就直接报错了，即使原线程并没有副本，实际上并不会产生并发冲突它也会报错。因此 Send 并不是强调所有权转移这个过程没有问题（虽然也可能有这一层意思），但是更重要的是不允许多个线程**同时存在**同样内容的该类型。

之后我们把 Rc 替换成 Arc 就总是能够正确计算引用计数并在多线程间共享引用了。其实 Rc 从某种程度上讲可以看成里面包裹内容的不可变引用，所以整体看有点像是里面包裹类型的 Sync。一条规则，类型 T 是 Sync 当且仅当类型 &T 是 Send 的。很容易说明该命题成立。Sync 就是指多个线程上允许**共存**该类型的同一个值的**不可变**引用。注意是不可变！所以 u32 这种原生类型也是 Sync 的。考虑经典的 `Rc<RefCell<T>>`，我们很容易在一个线程上通过 Rc 拿到 `&RefCell<T>`。可惜的是 RefCell 并不是 Sync 的。（这里考虑是否 Sync 而不是是否 Send 的原因在于归根到底 RefCell 是在堆上面唯一存在而不是每个栈上都可能有副本）。姑且假设有多个线程同时尝试 get_mut，而 RefCell 里面应该有一个变量标记目前已有的可变/不可变借用的数目，维护的时候不是原子的，于是 GG。

简单总结一下也就是说我们不太关心所有权转移/参数传递的过程中是否安全，而更关心稳定下来之后**共存**的状态是否安全。

新的重要术语：内部可变性（interior mutability） 和继承可变性（inherited mutability）。

官方文档提到若 T 是 sync 的，则 &mut T 也是 sync 的。这是因为 & &mut T 就不允许以可变的方式访问 T 了。

一些不内部可变的类型，如 Vec 或者 Box，也就是如果你只拿到不可变引用，多线程并发都不会有任何危险，因为都是只读的。若 T 是 sync 的，则加上 wrapper 之后依然是。

然而内部可变且线程不安全的类型，比如 Cell 或 RefCell，多个线程拿到它们的共享引用，就等于（在某种情况下）拿到了里面内容的多份独占引用，无论 T 是否 Sync 都会出问题。因此它们是不能 Sync 的。

之前确实没有想象到，用起来非常简单的 mut 在 Rust 的整个体系中可能也很关键。几乎一切并发的来源：同时只能有一个独占，却可以有多份共享。

## 2021-03-27

最近看到对于Rust内存安全模型的非常清晰的[讲解](https://www.bilibili.com/video/BV15N411o7e4)，我将这次的收获记录在下面。

首先需要对一些常用的术语给出明确的定义，因为即使在官方文档中它们的用法也常常被混淆。

**类型**：包括类型大小的字节数还有能够对它们进行的一些操作。

**值**：程序运行中，地址空间里一块连续的数据，带有类型信息。

**变量名**：当*拥有*一个值的时候，可以通过变量名来访问值。可以通过 ``let`` 或函数参数传递将值绑定到一个变量名上面，这会使得变量名*暂时*成为值的**拥有者**。所谓的**所有权**也就是指*变量名*拥有*值*。

**作用域**：只有*变量名*和*值*才有作用域的概念...（未完待续）



我先记录一些可能比较重要的东西，后面整合进来。

所谓的借用借用的是值，从代码实现的角度表现为借用拥有该值的变量名。而引用仅仅是实现借用的一种方式。

生存期（引用）和作用域（变量名、值）是两个不同的概念，但是二者之间可以进行比较。

对于一个函数而言，所有参数和返回值中的引用（除了 `&self, &mut self` 之外）的生存期均大于函数自身的生存期。实际上这些引用的生存期要在调用该函数的函数中去寻找。更加深入的解释只能求助于Rustonomicon中的协变了，现在先挖坑。

替代非词法作用域（NLL）的另一种借用检查器的实现[polonius](https://github.com/rust-lang/polonius)，以及相关的[原理介绍](http://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/)。

## 2021-12-25

最近在学习程序人生公众号作者的Rust入门课程，将一些收获整理在这里。

对于其他编程语言来说，对数据的引用不存在任何限制。而在Rust中，更精确的概念应该是借用（Borrow），它们的使用需要通过借用检查器的检验从而满足Rust的种种安全约束。所以在Rust语境中，什么时候应该用到引用呢？

与其他语言不同的是，Rust的函数调用并不区分传地址还是传值，**在Rust中所有的参数传递都是传值**，只是某些值的类型为引用类型。既然是传值，就要考虑Copy/Move语义。当类型实现了Copy Trait的时候，原来的值并不会被Move到新的变量中，而是新的变量会被绑定到一个新的值上，这个新的值是从旧的值按位复制（也即浅拷贝）过来的，原来的变量也仍然可以使用（并不会 use moved value）。当类型没有实现Copy Trait的时候，传参数则是取Move语义，也即原来变量的值被Move到新的变量中，原来变量处于Moved状态。另外一个相似的场景是两变量赋值，这里就不再赘述了。值得一提的是，共享借用实现了Copy Trait，但可变借用并没有实现Copy Trait，也就保证了同一时间一个值只能存在一个可变借用。

值对应到一块内存。我们可以将值绑定到变量上，从此变量成为值的拥有者（owner），在Rust代码中我们可以通过变量来访问绑定到它上面的值。那么当我们进行借用的时候，借用的是变量还是值呢？实际上借用的是值，考虑这样一种情况，当一个绑定到某变量上的值被销毁的时候，对于该值的所有借用也就失效了。

关于借用有一条重要性质：即借用的生存期不能长于（outlive）它借用的值的生命周期。这应该如何理解呢？我今天想到了一种新的解释方法：也即将程序分成代码和数据两个正交的区域。我们所讨论的所有的值都被保存在数据区域上，对应一块内存。而代码区域可以被理解为控制流，也就是将实际被执行的所有代码按照执行时间排列成一个序列。那么我们可以看到：数据区域每一个值都应该对应到代码区域的执行序列上的一段连续区间，在区间的开头，值被创建；在区间的结尾，值不再可用并被销毁，这个区间便是值的生命周期。这代码和数据两个区域分别描述了一个值在时间和空间上的属性。

因此，在思考借用的生存期的时候，我们也需要将借用当成一个值来思考，考虑它位于内存中的哪个区域，生命周期是哪段代码片段。同样我们也能够得到值的生命周期。在编译的时候编译器会通过借用检查来确定值的生命周期的确长于借用的生命周期。所以我们这里再强调一下：在Rust中只有值没有引用，只不过当值的类型是借用的话，它的生命周期和它借用的值的生命周期之间需要满足一定约束条件。

那么应该将变量放在什么位置呢？我觉得变量只是用来trace值的手段，因此问题的关键应该放在值上面。

程序的每一次执行都是从入口点开始，但每一次执行随着外部条件的不同都会不同，我们可以用调用栈上不断的push/pop来抽象这个过程。实际上每个函数也是存在生命周期的，从它某次被调用到它最终返回。容易看到，函数内的局部变量/参数的生命周期不长于函数自身的生命周期。但是当函数的输入/输出参数是借用的时候，情况则会有一些不同。首先，被借用的值必须来自于调用链的上游。其次，输出借用的生存期往往是调用者函数的一部分，且能够涵盖被调用函数的生命周期。与之相比，输入借用的生存期往往和被调用函数的生命周期相同。

---

Rust编译器开的两个后门（应该是位于unsafe Rust领域）：其一是Box::leak，可以脱离堆内存生命周期必定由创建它的栈内存控制的限制，可以使得堆内存有着自由的生命周期，甚至可以和进程本身有着相同的生命周期。其二是获取内部可变性，如`RefCell::borrow_mut`。

静态生命周期`'static`，动态生命周期如`'a,'b`（在栈上或者在堆上）。如果值是静态生命周期的，那么借用该值的应用也是静态生命周期的。当进行借用转换的时候（即通过一个借用不断得到另一个借用的时候，即“借用生成链”？），我觉得一条重要的原则可能是比如在赋值和函数返回的时候，左值的生命周期必须要短于右值的生命周期。这应该是显而易见的。或者另一种说法：引用只能不断转化为更短生命周期的引用，不然便有可能违背引用生命周期不能长于值生命周期的原则。

大多数函数或结构体的生命周期标注只会用到同一个生命周期，在某些罕见的情况下需要用到多个生命周期，这种情况常常是涉及到多个并不能被视作相同的生命周期。我们提到生命周期是一个泛型，那么如何进行实例化呢？比如说，如果有两个事实上不同的生命周期被标注为同一个泛型，那泛型会被实例化为二者中较短的生命周期。而如果输出同样被标注为`'a`的话，其语义是函数签名保证输出引用的生命周期outlive `'a`（很多文档都是这样的说法）。

看Rust死灵书看到一个非常好的例子：

```rust
let mut data = vec![1, 2, 3];
let x = &data[0];
data.push(4);
println!("{}", x);

'a: {
    let mut data: Vec<i32> = vec![1, 2, 3];
    'b: {
        // 'b is as big as we need this borrow to be
        // (just need to get to `println!`)
        let x: &'b i32 = Index::index::<'b>(&'b data, 0);
        'c: {
            // Temporary scope because we don't need the
            // &mut to last any longer.
            Vec::push(&'c mut data, 4);
        }
        println!("{}", x);
    }
}
```

注意这里面`index`的函数签名。它指出：`index`的返回值**关联**到输入的数据源，因此，在返回值引用存在期间，实际上也借用了输入数据源，因此在此期间也存在一个对输入数据源的借用。注意，在这个上下文中我们其实并不知道`x`到底和`data`是什么关系（这和`index`的实现有关），但我们很清楚的知道它也是一类对`data`的借用。然后再看下面的`'c`作用域，里面有一个对`data`的可变借用，而在此期间只读借用`&'b data`仍然存在，这就违背了借用的基本规则。

因此：函数签名中的生命周期的重要意义在于为输入/输出建立关联。比如输入/输出都是一个`'a`，那么其含义是：在输出引用存在期间，输入引用必定存在。从最小化原则来考虑，输入引用只要跟输出引用一样长就好了。毕竟输入引用越长的话，就越有可能产生冲突。其实这是逆向思维：从编译器的角度考虑，由于输入和输出之间有这样的关系，那么为了输出能够得到使用，那么最起码在输出被使用期间输入需要被预定一个borrow。我个人认为这个应该是返回值引用生命周期的实质。

那么假如存在多个输入参数呢？考虑crust of rust里面的例子：当我们使用一个局部的delimiter和一个全局的haystack的时候，首先选取两个输入的公共区间——也就是局部作用域，然后根据函数签名，我们要求返回值存在期间两个数据源都要存在。这显然是不正确的，因为返回值的生命周期长于局部作用域。反之，如果我们声称delimiter和haystack是两个不同的生命周期，并将输出的数据源绑定到haystack，就只会要求输出存在期间haystack必定存在，delimiter的生命周期完全与输出无关。事实上我们仅是在find期间传入了delimiter，而不用考虑其他影响。

这里可以有一种有趣的说法：即**视角转换**。我们尝试从一些输入引用构建另一个输出引用，在此之后，我们的视角就转换到输出引用上面了。但我们仍需要注意，我们需要考虑输出引用隐式借用了哪些数据——这取决于我们在函数签名中是如何进行输入输出之间的绑定的。当我们在函数签名中使用同一种标注，其实本质含义并不是进行生命周期的约束，而是告诉编译器**输出与哪些输入有关**，又与哪些输入无关。当存在一些可疑的别名的时候，编译器也许并不能很好的做到这一点。

另外，在课程讨论区看到：当结构体内仅存在一个引用的时候，理论上编译器有能力自动完成生命周期标注。但出于代码可读性目前并没有这样做。

