# 1. 引言

感谢原作者，内容来自[这里](https://danielkeep.github.io/tlborm/book/index.html)。

# 2. 宏的理论介绍

## 2.1 语法拓展

### 2.1.1 源代码分析

在 Rust 的编译流程中，第一步是进行词法分析，即将作为最小单位的 token 分离出来。token 的种类有很多，包括：标识符、整数、关键字、生命周期标志、字符串字面量、运算符等等。值得一提的是：

* 在绝大多数情况下， `self` 都是一个关键字，但它在某些情况下也有可能被当成一个标识符来处理；
* 在上面给出的关键字列表中的 `yield, macro` 看上去有些令人怀疑，事实上它们并没有在语言中，但是会被编译器识别并标记为留待今后使用；
* 运算符列表也包含一些不会被 Rust 使用的运算符，比如 `<-` 被从语法中移除，但却还被保留在词法分析中； 
* 注意 `::` 是一个整体的 token 而不是两个 `:` token，其他多字符的 token 也是这样。

事实上如 C/C++ 等语言在词法分析过程中就可以高效完成宏替换，但是 Rust 并不支持。

下一个阶段是进行解析，即将一个 token 流转化为一颗抽象语法树（AST），这在内存中建立起了整个程序的语法结构。然而目前它仅仅基于已有的词法信息，举例来说，它看到 `a` 这个变量出现在运算符的一端，但是它既不清楚变量的类型，也不知道这个变量在何处被定义。

#### 标记树 Token Tree

标记树介于 token 和抽象语法树之间，几乎所有的 token 也是标记树，更具体的，它们是标记树上的叶节点。除了 token 之外还有另一样东西可以作为标记树的叶节点，这个我们稍后再说明。

最基本的 token 并不是作为叶子的 token 而是包括 `(...), [...], {...}` 在内的“分组” token，它们作为标记树的内部节点而存在。举例来说，一个 token 序列

```
a + b + (c + d[0]) + e
```

会被解析成这样的标记树：

```
«a» «+» «b» «+» «(   )» «+» «e»
          ╭────────┴──────────╮
           «c» «+» «d» «[   ]»
                        ╭─┴─╮
                         «0»
```

注意，这颗标记树和这个表达式最终转化成的抽象语法树并没有关系。抽象语法树只有一个根节点，而标记树在深度最低的一层却有多个节点。理解标记树与抽象语法树之间的差别很重要。当编写宏的时候，我们需要同时与二者打交道。

另外需要提到的是，不允许出现未匹配的 `{}` (braces)、`[]`(brackets)、`()`(parentheses)，这也无法正确生成一颗标记树。

### 2.1. 2 抽象语法树中的宏

正如之前所提到的那样，在 Rust 中宏替换在抽象语法树构造完成之后再进行。用来触发宏的语法必须是 Rust 语法的一个合适的部分。事实上，在 Rust 的语法中有一些拓展语法范式。更具体点，有以下拓展语法：

* `# [ $arg ]`，如 `#[derive(Clone)], #[no_mangle]`；
* `# ! [ $arg ]`，如 `#![allow(dead_code)], #![crate_name="blang"]`；
* `\$name ! \$arg`，如 `println!("Hi!"), concat!("a", "b")`；
* `\$name ! \$arg0 \$arg1`，如 `macro_rules! dummy { () => {}; }`。

其中前两种被称为“属性”，如 `#[repc(C)], #[derive(Clone)]`，目前不能定义这种类型的宏。

第三种是我们感兴趣的类型，它可以被宏来使用。但其实它是一种通用的拓展语法，比如 `format!` 是宏，而 `format_args!` 却不是。

第四种从本质上来说是一种不能被宏所使用的变种，事实上，它仅会用在 `macro_rules!` 中。

考虑第三种 `\$name ! \$arg`，有一个问题，Rust 解析器如何对于每一种可能的拓展语法，知道其中的 `\$arg` 是什么样子的呢？答案是 Rust 解析器不需要知道。与之相反，拓展语法调用的参数部分是一颗标记树的非叶子节点，对应于 `(...), [...], {...}` 三者的其中之一。了解了这些之后，我们可以更加直观地理解解析器如何识别以下的调用格式：

```rust
bitflags! {
    flags Color: u8 {
        const RED    = 0b0001,
        const GREEN  = 0b0010,
        const BLUE   = 0b0100,
        const BRIGHT = 0b1000,
    }
}

lazy_static! {
    static ref FIB_100: u32 = {
        fn fib(a: u32) -> u32 {
            match a {
                0 => 0,
                1 => 1,
                a => fib(a-1) + fib(a-2)
            }
        }

        fib(100)
    };
}

fn main() {
    let colors = vec![RED, GREEN, BLUE];
    println!("Hello, World!");
}
```

尽管上述的宏调用看起来包含了多种多样的 Rust 代码，但解析器其实只会简单的将他们看成一个包含若干无意义的标记树的一个集合。我们可以将被解析器忽略的代码用 `⬚` 来代替从而看的更加清楚：

```rust
bitflags! ⬚

lazy_static! ⬚

fn main() {
    let colors = vec! ⬚;
    println! ⬚;
}
```

需要在这里重复说明的是，解析器不会对 `⬚` 做任何假定，它只是记录下其中包含的 tokens，而不会尝试做任何理解或解析工作。

比较重要的是：

* 在 Rust 当中有多种语法拓展，但在这里我们只讨论通过 `macro_rules!` 定义的宏；
* 形如 `\$name ! \$arg` 的语法拓展不一定是一个宏，也有可能是一种其他的语法拓展；
* 每个宏的输入都是一颗标记树的非叶子节点；
* 宏（事实上，对于其他语法拓展也成立）会被解析成抽象语法树的一部分。

最后一点是最重要的。由于宏会被解析到抽象语法树中，它们只能出现在它们被显式支持的地方，如模式、语句、表达式、Item、`impl` Item 中，然而，却不能出现在标识符、match arm、结构体、类型中。

### 2.1.3 宏展开

展开是一项相对简单的任务。当 AST 构造完成之后，编译器会将所有的宏展开成实际的代码，然后再去理解程序的语义。宏展开的过程需要遍历 AST，找到宏被调用的位置并将其替换成它的展开。对于那些除了宏之外的语法拓展，展开流程取决于具体的语法拓展。当展开完成之后，包括宏在内的所有语法拓展可以认为没有任何差距，会以相同的方式进行进一步的处理。

在编译器进行宏展开的时候，基于当时的上下文，它希望结果能够被解析成一个有限的语法元素集合。举例，当你在模块域调用了一个宏，编译器会将解析结果放到一个代表 Item 的 AST 节点上。若你在表达式中使用宏，那么编译器会将解析结果放到一个代表表达式的 AST 节点上。

实际上，编译器能将语法拓展的解析结果放到下述位置：一个表达式；一个 Pattern；零个或多个 Items；零个或多个 `impl` Items；零条或多条语句中。

换句话来说，你在哪里调用了宏也就决定了宏会被翻译成什么。

考虑下面的宏调用：

```rust
let eight = 2 * four!();
```

相关部分的抽象语法树如下：

```rust
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │
     │ val: 2 │                 │ name: four │
     └────────┘                 │ body: ()   │
                                └────────────┘
```

从上下文来看，`four!` 必须被展开成一个表达式。因此，无论它实际会被展开成什么样，它都会被解释成一个完整的表达式。这里，我们不妨假设 `four!` 的定义使得它会被展开成 `1 + 3` 这样一个表达式。那么，将这个宏调用展开将会使得抽象语法树变成下面这个样子：

```rust
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
     │ val: 2 │                 │ op: Add │
     └────────┘               ┌╴│ lhs: ◌  │
                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                   │ val: 1 │                 │ val: 3 │
                   └────────┘                 └────────┘
```

其等价的 Rust 代码可以看成：

```rust
let eight = 2 * (1 + 3);
```

注意到，尽管括号没在宏展开中出现，我们还是在代码中把它加上了。回忆一下，编译器总会将宏展开当成一个完整的 AST 节点，而不仅是一个 token 序列。更进一步，即使你没有显式地给复杂的表达式加上括号，编译器也不会曲解你的意思，比如更改你期望的计算顺序。

理解宏展开会被编译器当作 AST 节点非常重要，这个设计有两个更深远的含义：

* 我们之前知道宏只能够在若干有限的位置被调用，现在我们还知道，宏只能被展开成它被调用的位置期望它被展开成的那种 AST 节点；
* 上一条导致宏绝对不能被展开成不完整、或是不符合语法的结构。

对于宏展开还有一点需要注意：当一个宏被展开成其中含有另一个宏调用的时候，会发生什么呢？比如，当宏 `four!` 被展开成 `1 + three!()` 会怎么样？

```rust
let x = four!();
```

被展开成：

```rust
let x = 1 + three!();
```

事实上，编译器会检查宏展开结果是否出现了新的宏调用，如果有的话它会将其进一步展开。经过了第二次展开之后，最终的结果如下：

```rust
let x = 1 + 3;
```

然而，这个过程并不是无止境进行的，编译器规定递归展开的最大层数为 $32$ 。当超出最大层数时，编译器将会退出并报错。这个上限可以通过 `#![recursion_limit=...]` 来修改。但一般情况下不建议这样做。

## 2.2 `macro_rules!`

学习了上面的知识之后，我们可以引入 `macro_rules!` 了。正如之前所提到的那样，`macro_rules!` 自己就是一个语法拓展，意味着它从技术角度来讲并不是 Rust 语法的一部分。它的格式如下：

```rust
macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // ..
    $ruleN ;
}
```

要求至少有一条规则，最后一条规则之后的分号可以省略。每条“规则”形如：

```rust
	($pattern) => {$expansion}
```

事实上，括号和花括号可以替换为其他分组运算符，但人们一直以来习惯在 pattern 两边加上括号，用花括号来包裹 expansion。

如果你感兴趣，我可以告诉你，`macro_rules!` 调用会被展开成... *虚无*。至少，在 AST 上我们什么都看不到。事实上，它修改编译器内部的数据结构来注册宏。正因如此，你可以在空白展开合法的任意位置使用 `macro_rules!` 宏。

#### 匹配

当一个宏被调用时， `macro_rules!` 解释器按照字典序依次遍历每条规则，尝试将输入的标记树节点与规则中的 pattern 进行匹配。pattern 必须完全与输入的标记树节点匹配才会被视为匹配成功。一旦匹配成功，宏调用就会被替换成规则中的 expansion。如果宏调用与所有的规则均不能匹配成功，那么宏展开过程就会报错退出。

最简单的例子是一个空的 pattern：

```rust
macro_rules! four {
    () => {1 + 3};
}
```

它仅会在 `four!` 的输入为空的时候匹配成功（如 `four!(), four![], four!{}`）。

注意当你在调用宏的时候分组 token 并不会被匹配。也就是说，通过 `four![]` 调用上面的宏仍能够匹配成功。仅有输入的标记树中的内容才会被考虑。

Pattern 也可以包含字面量的标记树节点，它们必须被完全匹配。这只要简单的把他们写下来就行了，例如，要匹配 token 序列 `4 fn ['spang "whammo"] @_@`，可以通过：

```rust
macro_rules! gibberish {
    (4 fn ['spang "whammo"] @_@) => {...};
}
```

只要你能够写下来的标记树都能够使用。

#### 捕获

Pattern 中可以包括捕获，它们允许将输入基于一些通用的语法类型进行匹配，并将结果捕获到一个变量进而替换到输出中。捕获的格式为 `$<identifier>: <capture_kind>`，其中 `<capture_kind>` 只能为下面的其中之一：

* `item`: 一个 Item，比如函数、结构体、模块等；
* `block`: 一个代码块；
* `stmt`: 一条语句；
* `pat`: 一个 pattern；
* `expr`: 一个表达式；
* `ty`: 一个类型；
* `ident`: 一个标识符；
* `path`: 一个路径（如 `foo, ::std::mem::replace, transmute::<\_, int>,...`）；
* `meta`: 一个元项，指在属性 `#[...], #![...]` 里面的内容；
* `tt`: 一个标记树节点

例如，下面是一个能够将输入作为一个表达式捕获的宏：

```rust
macro_rules! one_expression {
    ($e:expr) => {...};
}
```

捕获利用了 Rust 编译器中的解析模块，确保捕获总是正确的。一个类型为 `expr` 的捕获总是会捕获到一个对于目前 Rust 版本而言完整、合法的表达式。

在一定的限制下，你可以将字面量标记树与捕获进行混合，下面会进行解释。

一个形如 `\$<name>:<capture_kind>` 的捕获可以通过 `\$<name>` 将捕获到的内容替换到展开中。比如：

```rust
macro_rules! times_five {
    ($e:expr) => {5 * $e};
}
```

和宏展开一样，捕获也会被替换成一个完整的 AST 节点。这意味着无论 `$e` 捕获到了怎样的一个 token 序列，它都会被解释成单个完整的表达式。

在单个 pattern 中还可以同时有多个捕获：

```rust
macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) => {$a * ($b + $c)};
}
```

#### 重复

pattern 中可以使用重复来匹配一个 token 序列，其格式为 `$ (...) sep rep`。其中：

* `(...)` 是使用括号分组的会在输入 token 序列中重复多次的一个模式；
* `sep` 是一个可选的分隔符，常见的备选项为 `,` 和 `;`；
* `rep` 是一个可选的重复次数控制选项，`*` 表示重复零次或多次，而 `+` 表示重复一次到多次。只能使用以上两种设置。

重复可以包含其他任何合法模式，包括字面标记、捕获以及其他重复。

比如，下面的例子可以匹配零个或多个用逗号分隔的表达式并展开成一个构建成一个 Vector 的表达式。

```rust
macro_rules! vec_strs {
    ($($element:str) , *) => {
        {
            let mut v = Vec::new();
            
            $(
                v.push(format!("{}", $element));
            )*
            
            v
        }
    }
}
```

# 未完待续...



